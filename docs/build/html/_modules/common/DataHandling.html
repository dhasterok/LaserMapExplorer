
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>common.DataHandling &#8212; Laser Map Explorer 0.1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/mpl.css?v=369bd9d1" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/custom.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/common/DataHandling';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/LaME-wide-64.svg" class="logo__image only-light" alt=""/>
    <img src="../../_static/LaME-wide-green-64.svg" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">LaME v.0.0 beta</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../userguide.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../tutorials.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../documentation.html">
    Documentation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../contact.html">
    Contact
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../labels.html">
    <no title>
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dhasterok/LaserMapExplorer" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://minexcrc.com.au/" title="MinEx CRC" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/minex_crc_logo.svg" class="icon-link-image" alt="MinEx CRC"/></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../userguide.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../tutorials.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../documentation.html">
    Documentation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../contact.html">
    Contact
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../labels.html">
    <no title>
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/dhasterok/LaserMapExplorer" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://minexcrc.com.au/" title="MinEx CRC" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/minex_crc_logo.svg" class="icon-link-image" alt="MinEx CRC"/></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">common.DataHandling</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for common.DataHandling</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">src.common.ExtendedDF</span> <span class="kn">import</span> <span class="n">AttributeDataFrame</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">yeojohnson</span>
<span class="c1"># from kneed import KneeLocator</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">src.common.format</span> <span class="k">as</span> <span class="nn">fmt</span>
<span class="kn">from</span> <span class="nn">src.common.Observable</span> <span class="kn">import</span> <span class="n">Observable</span>
<span class="kn">from</span> <span class="nn">src.common.SortAnalytes</span> <span class="kn">import</span> <span class="n">sort_analytes</span>
<span class="kn">from</span> <span class="nn">src.common.outliers</span> <span class="kn">import</span> <span class="n">chauvenet_criterion</span><span class="p">,</span> <span class="n">quantile_and_difference</span>
<span class="kn">from</span> <span class="nn">PyQt6.QtWidgets</span> <span class="kn">import</span> <span class="n">QMessageBox</span>
<span class="kn">from</span> <span class="nn">src.common.Status</span> <span class="kn">import</span> <span class="n">StatusMessageManager</span>
<span class="kn">from</span> <span class="nn">src.common.format</span> <span class="kn">import</span> <span class="n">symlog</span>
<span class="kn">from</span> <span class="nn">src.common.Logger</span> <span class="kn">import</span> <span class="n">LoggerConfig</span><span class="p">,</span> <span class="n">auto_log_methods</span>

<div class="viewcode-block" id="SampleObj">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj">[docs]</a>
<span class="nd">@auto_log_methods</span><span class="p">(</span><span class="n">logger_key</span><span class="o">=</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SampleObj</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a sample object to store and manipulate geochemical data in map form</span>
<span class="sd">    </span>
<span class="sd">    The sample object is initially constructed from the data within a *.lame.csv file and loaded into</span>
<span class="sd">    the ``raw_data`` dataframe.  The sample object also contains a number of properties in addition</span>
<span class="sd">    to the input data.  These include metadata that are linked to each column.  To make this link,</span>
<span class="sd">    the dataframe is initialized as an ``ExtendedDF.AttributeDataFrame``, which brings with it a</span>
<span class="sd">    number of methods to set, get and search the dataframe&#39;s metadata.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sample_id : str</span>
<span class="sd">        Sample identifier.</span>
<span class="sd">    file_path : str</span>
<span class="sd">        Path to data file for sample_id</span>
<span class="sd">    outlier_method : str</span>
<span class="sd">        Method used ot handle outliers in the dataset</span>
<span class="sd">    negative_method : str</span>
<span class="sd">        Method used to handle negative values in the dataset</span>
<span class="sd">    ref_chem : pandas.DataFrame</span>
<span class="sd">        Reference chemistry for normalizing data</span>
<span class="sd">    debug : bool, optional</span>
<span class="sd">        If true, will result in verbose output to stdout</span>
<span class="sd">    </span>
<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    reset_data :</span>
<span class="sd">        Reverts back to the original data</span>

<span class="sd">    add_columns :</span>
<span class="sd">        Add one or more columns to the sample object</span>

<span class="sd">    delete_column :</span>
<span class="sd">        Deletes a column and associated attributes from the AttributeDataFrame</span>

<span class="sd">    get_attribute_dict :</span>
<span class="sd">        Creates a dictionary from an attribute where the unique values of the attribute becomes the</span>
<span class="sd">        keys and the items are lists with the column names that match each attribute_name</span>

<span class="sd">    swap_xy : </span>
<span class="sd">        Swaps data in a SampleObj</span>

<span class="sd">    _swap_xy :</span>
<span class="sd">        Swaps X and Y of a dataframe</span>
<span class="sd">    </span>
<span class="sd">    swap_resolution :</span>
<span class="sd">        Swaps DX and DY for a dataframe</span>

<span class="sd">    reset_crop :</span>
<span class="sd">        Reset the data to the new bounds.</span>

<span class="sd">    compute_ratio :</span>
<span class="sd">        Compute a ratio field from two analytes</span>

<span class="sd">    cluster_data :</span>
<span class="sd">        Clusters data for use with data preprocessing</span>


<span class="sd">    prep_data :</span>
<span class="sd">        Applies adjustments to data data prior to analyses and plotting</span>

<span class="sd">    k_optimal_clusters :</span>
<span class="sd">        Predicts the optimal number of clusters</span>

<span class="sd">    outlier_detection :</span>
<span class="sd">        Outlier detection with cluster-based correction for negatives and compositional constraints, using percentile-based shifting</span>

<span class="sd">    transform_array :</span>
<span class="sd">        Negative and zero handling with clustering for noise detection</span>

<span class="sd">    update_norm :</span>
<span class="sd">        Update the norm of the data</span>

<span class="sd">    get_map_data :</span>
<span class="sd">        Retrieves and processes the mapping data for the given sample and analytes</span>

<span class="sd">    get_processed_data :</span>
<span class="sd">        Gets the processed data for analysis</span>

<span class="sd">    get_vector :</span>
<span class="sd">        Creates a dictionary of values for plotting</span>

<span class="sd">    ref_chem : dict</span>
<span class="sd">        Reference chemistry. By default `None`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    update_crop_mask :</span>
<span class="sd">        Automatically update the crop_mask whenever crop bounds change.</span>
<span class="sd">    reset_crop : </span>
<span class="sd">        Resets dataframe to original bounds.</span>
<span class="sd">    raw_data :</span>
<span class="sd">    filter_df : (pandas.DataFrame) -- stores filters for each sample</span>
<span class="sd">        | &#39;field_type&#39; : (str) -- field type</span>
<span class="sd">        | &#39;field&#39; : (str) -- name of field</span>
<span class="sd">        | &#39;norm&#39; : (str) -- scale normalization function, ``linear`` or ``log``</span>
<span class="sd">        | &#39;min&#39; : (float) -- minimum value for filtering</span>
<span class="sd">        | &#39;max&#39; : (float) -- maximum value for filtering</span>
<span class="sd">        | &#39;operator&#39; : (str) -- boolean operator for combining filters, ``and`` or ``or``</span>
<span class="sd">        | &#39;use&#39; : (bool) -- ``True`` indicates the filter should be used to filter data</span>
<span class="sd">        | &#39;persistent&#39; : (bool) -- ``True`` retains the filter when the sample is changed</span>

<span class="sd">        | &#39;crop&#39; : () --</span>
<span class="sd">        | &#39;x_max&#39; : () --</span>
<span class="sd">        | &#39;x_min&#39; : () --</span>
<span class="sd">        | &#39;y_max&#39; : () --</span>
<span class="sd">        | &#39;y_min&#39; : () --</span>
<span class="sd">        | &#39;crop_x_max&#39; : () --</span>
<span class="sd">        | &#39;crop_x_min&#39; : () --</span>
<span class="sd">        | &#39;crop_y_max&#39; : () --</span>
<span class="sd">        | &#39;crop_y_min&#39; : () --</span>
<span class="sd">        | &#39;processed data&#39;: () --</span>
<span class="sd">        | &#39;raw_data&#39;: () -- </span>
<span class="sd">        | &#39;cropped_raw_data&#39;: () --</span>
<span class="sd">            </span>
<span class="sd">        | &#39;crop&#39; : () --</span>
<span class="sd">        | &#39;x_max&#39; : () --</span>
<span class="sd">        | &#39;x_min&#39; : () --</span>
<span class="sd">        | &#39;y_max&#39; : () --</span>
<span class="sd">        | &#39;y_min&#39; : () --</span>
<span class="sd">        | &#39;crop_x_max&#39; : () --</span>
<span class="sd">        | &#39;crop_x_min&#39; : () --</span>
<span class="sd">        | &#39;crop_y_max&#39; : () --</span>
<span class="sd">        | &#39;crop_y_min&#39; : () --</span>
<span class="sd">        | &#39;raw_data&#39;: () -- </span>
<span class="sd">        | &#39;cropped_raw_data&#39;: () -- </span>
<span class="sd">        | &#39;raw data&#39; : (pandas.DataFrame) --</span>
<span class="sd">        | &#39;x_min&#39; : (float) -- minimum x of full data</span>
<span class="sd">        | &#39;x_max&#39; : (float) -- maximum x of full data</span>
<span class="sd">        | &#39;y_min&#39; : (float) -- minimum y of full data</span>
<span class="sd">        | &#39;y_max&#39; : (float) -- maximum y of full data</span>
<span class="sd">        | &#39;crop_x_min&#39; : (float) -- minimum x of cropped data</span>
<span class="sd">        | &#39;crop_x_max&#39; : (float) -- maximum x of cropped data</span>
<span class="sd">        | &#39;crop_x_min&#39; : (float) -- minimum y of cropped data</span>
<span class="sd">        | &#39;crop_x_max&#39; : (float) -- maximum y of cropped data</span>
<span class="sd">        | &#39;norm&#39; : () --</span>
<span class="sd">        | &#39;analysis data&#39; : (pandas.DataFrame) --</span>
<span class="sd">        | &#39;cropped_raw_data&#39; : (pandas.DataFrame) --</span>

<span class="sd">    &#39;processed_data&#39; : (pandas.DataFrame) --</span>
<span class="sd">    &#39;crop_mask&#39; : (MaskObj) -- mask created from cropped axes.</span>
<span class="sd">    &#39;filter_mask&#39; : (MaskObj) -- mask created by a combination of filters.  Filters are displayed for the user in ``tableWidgetFilters``.</span>
<span class="sd">    &#39;polygon_mask&#39; : (MaskObj) -- mask created from selected polygons.</span>
<span class="sd">    &#39;cluster_mask&#39; : (MaskObj) -- mask created from selected or inverse selected cluster groups.  Once this mask is set, it cannot be reset unless it is turned off, clustering is recomputed, and selected clusters are used to produce a new mask.</span>
<span class="sd">    &#39;mask&#39; : () -- combined mask, derived from filter_mask &amp; &#39;polygon_mask&#39; &amp; &#39;crop_mask&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_id</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">outlier_method</span><span class="p">,</span> <span class="n">negative_method</span><span class="p">,</span> <span class="n">smoothing_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ref_chem</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger_key</span> <span class="o">=</span> <span class="s1">&#39;Data&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sample_id</span> <span class="o">=</span> <span class="n">sample_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span> <span class="o">=</span> <span class="n">file_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_field</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_outlier_method</span> <span class="o">=</span> <span class="n">outlier_method</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_negative_method</span> <span class="o">=</span> <span class="n">negative_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothhing_method</span> <span class="o">=</span> <span class="n">smoothing_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_default_lower_bound</span> <span class="o">=</span> <span class="mf">0.005</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_upper_bound</span> <span class="o">=</span> <span class="mf">0.995</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_default_difference_lower_bound</span><span class="o">=</span> <span class="mf">0.005</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_difference_upper_bound</span><span class="o">=</span> <span class="mf">0.995</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data_min_quantile</span> <span class="o">=</span> <span class="mf">0.005</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_max_quantile</span> <span class="o">=</span> <span class="mf">0.005</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_min_diff_quantile</span> <span class="o">=</span> <span class="mf">0.005</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_max_diff_quantile</span> <span class="o">=</span> <span class="mf">0.005</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_chem</span> <span class="o">=</span> <span class="n">ref_chem</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ny</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># filter dataframe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;use&#39;</span><span class="p">,</span> <span class="s1">&#39;field_type&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;operator&#39;</span><span class="p">,</span> <span class="s1">&#39;persistent&#39;</span><span class="p">])</span>

        <span class="c1"># axis dictionary for plotting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># data types stored in AttributeDataFrames.column_attributes[&#39;data_type&#39;]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_data_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Analyte&#39;</span><span class="p">,</span><span class="s1">&#39;Ratio&#39;</span><span class="p">,</span><span class="s1">&#39;Computed&#39;</span><span class="p">,</span><span class="s1">&#39;Special&#39;</span><span class="p">,</span><span class="s1">&#39;PCA score&#39;</span><span class="p">,</span><span class="s1">&#39;Cluster&#39;</span><span class="p">,</span><span class="s1">&#39;Cluster score&#39;</span><span class="p">]</span>

        <span class="c1"># matrix order set by x-y sorting, which changes when swapping axes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_swapped</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spotdata</span> <span class="o">=</span> <span class="n">AttributeDataFrame</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset_data</span><span class="p">()</span>

<div class="viewcode-block" id="SampleObj.reset_data">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.reset_data">[docs]</a>
    <span class="k">def</span> <span class="nf">reset_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reverts back to the original data.</span>

<span class="sd">        What is reset?</span>

<span class="sd">        What is not reset?</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># load data</span>
        <span class="n">metadata_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.lame.&#39;</span><span class="p">,</span><span class="s1">&#39;.lmdf.&#39;</span><span class="p">)</span>
        <span class="n">metadata_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">metadata_path</span><span class="p">):</span>
            <span class="n">metadata_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>

        <span class="n">sample_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
        <span class="n">sample_df</span> <span class="o">=</span> <span class="n">sample_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="o">~</span><span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;^Unnamed&#39;</span><span class="p">)]</span>  <span class="c1"># Remove unnamed columns</span>

        <span class="c1"># determine column data types</span>
        <span class="c1"># initialize all as &#39;Analyte&#39;</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Analyte&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">sample_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># identify coordinate columns</span>
        <span class="n">data_type</span><span class="p">[</span><span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s1">&#39;Xc&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;coordinate&#39;</span>
        <span class="n">data_type</span><span class="p">[</span><span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s1">&#39;Yc&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;coordinate&#39;</span>

        <span class="c1"># identify and ratio columns</span>
        <span class="n">ratio_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-Za-z]+[0-9]*) / ([A-Za-z]+[0-9]*)&#39;</span><span class="p">)</span>

        <span class="c1"># List to store column names that match the ratio pattern</span>
        <span class="n">ratio_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">ratio_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">col</span><span class="p">)]</span>

        <span class="c1"># Update the data_type list for ratio columns by finding their index positions</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ratio_columns</span><span class="p">:</span>
            <span class="n">col_index</span> <span class="o">=</span> <span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">data_type</span><span class="p">[</span><span class="n">col_index</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Ratio&#39;</span>

        <span class="c1"># use an ExtendedDF.AttributeDataFrame to add attributes to the columns</span>
        <span class="c1"># may includes analytes, ratios, and special data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span> <span class="o">=</span> <span class="n">AttributeDataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="s1">&#39;data_type&#39;</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>

        <span class="c1"># initialize X and Y axes bounds for plotting and cropping, initially the entire map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xlim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ylim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>

        <span class="c1"># initialize crop flag to false</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Remove the ratio columns from the raw_data and store the rest</span>
        <span class="c1">#non_ratio_columns = [col for col in sample_df.columns if col not in ratio_columns]</span>
        <span class="c1">#self.raw_data = sample_df[non_ratio_columns]</span>

        <span class="c1"># set mask of size of analyte array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crop_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygon_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">crop_mask</span> <span class="o">&amp;</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span> <span class="o">&amp;</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">polygon_mask</span> <span class="o">&amp;</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_mask</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dim_red_results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silhouette_scores</span> <span class="o">=</span> <span class="p">{}</span>


        <span class="c1"># autoscale and negative handling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_data_handling</span><span class="p">()</span></div>


<div class="viewcode-block" id="SampleObj.reset_data_handling">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.reset_data_handling">[docs]</a>
    <span class="k">def</span> <span class="nf">reset_data_handling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        _extended_summary_</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">coordinate_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">match_attribute</span><span class="p">(</span><span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;data_type&#39;</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;coordinate&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">coordinate_columns</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">coordinate_columns</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">analyte_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">match_attribute</span><span class="p">(</span><span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;data_type&#39;</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;Analyte&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># quantile bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;lower_bound&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;upper_bound&#39;</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">)</span>
        <span class="c1"># quantile bounds for differences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;diff_lower_bound&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;diff_upper_bound&#39;</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
        <span class="c1"># linear/log scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;auto_scale&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="n">analyte_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">match_attribute</span><span class="p">(</span><span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;data_type&#39;</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;Ratio&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># quantile bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;lower_bound&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_lower_bound</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;upper_bound&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_upper_bound</span><span class="p">)</span>
        <span class="c1"># quantile bounds for differences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;diff_lower_bound&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_difference_lower_bound</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;diff_upper_bound&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_difference_upper_bound</span><span class="p">)</span>
        <span class="c1"># linear/log scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;auto_scale&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># cluster data</span>
        <span class="c1"># This determines the optimal number of clusters and creates cluster indicies that are used for preprocessing.</span>
        <span class="c1"># This should only need to be run once on the initial raw data, unless the set of used analytes changes.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_data</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="p">()</span></div>

    
    <span class="c1"># def update_crop_mask(self):</span>
    <span class="c1">#     &quot;&quot;&quot;Automatically update the crop_mask whenever crop bounds change.&quot;&quot;&quot;</span>
    <span class="c1">#     for analysis_type, df in self.computed_data.items():</span>
    <span class="c1">#         if isinstance(df, pd.DataFrame):</span>
    <span class="c1">#             df = df[self.crop_mask].reset_index(drop=True)</span>
    <span class="c1">#     self.prep_data()</span>

    <span class="c1"># --------------------------------------</span>
    <span class="c1"># Define properties and setter functions</span>
    <span class="c1"># --------------------------------------</span>
    <span class="c1"># note properties are based on the cropped X and Y values</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ref_chem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;dict: Reference chemistry&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_chem</span>

    <span class="nd">@ref_chem</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ref_chem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_chem</span> <span class="o">=</span> <span class="n">d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Value of x-coordinate associated with map data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_x</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">new_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_range</span> <span class="o">/</span> <span class="n">new_x</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nx</span> <span class="o">=</span> <span class="n">new_x</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Define the y property</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Value of y-coordinate associated with map data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>

    <span class="nd">@y</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_y</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">new_y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span> <span class="o">/</span> <span class="n">new_y</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_ny</span> <span class="o">=</span> <span class="n">new_y</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: Width of pixels in x-direction.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span>

    <span class="nd">@dx</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dx</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Recalculates X for self.raw_data</span>
            <span class="c1"># (does not use self.processed_data because the x limits will otherwise be incorrect)</span>
            <span class="c1"># X = round(self.raw_data[&#39;Xc&#39;]/self._dx)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_dx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span> <span class="o">=</span> <span class="n">new_dx</span>
            <span class="n">X_new</span> <span class="o">=</span> <span class="n">new_dx</span><span class="o">*</span><span class="n">X</span>

            <span class="c1"># Extract cropped region and update self.processed_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">X_new</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;dx&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span><span class="p">)</span>
        
            

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: Width of pixels in y-direction.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy</span>

    <span class="nd">@dy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dy</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Recalculates Y for self.raw_data</span>
            <span class="c1"># (does not use self.processed_data because the y limits will otherwise be incorrect)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_dy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dy</span> <span class="o">=</span> <span class="n">new_dy</span>
            <span class="n">Y_new</span> <span class="o">=</span> <span class="n">new_dy</span><span class="o">*</span><span class="n">Y</span>

            <span class="c1"># Extract cropped region and update self.processed_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">Y_new</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_updating</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;dy&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy</span><span class="p">)</span>
        

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nx</span>
    
    <span class="nd">@nx</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">nx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_nx</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_nx</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nx</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nx</span> <span class="o">=</span> <span class="n">new_nx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;nx&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nx</span><span class="p">)</span>
        

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ny</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ny</span>
    
    <span class="nd">@ny</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ny</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_ny</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_ny</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ny</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ny</span> <span class="o">=</span> <span class="n">new_ny</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;ny&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ny</span><span class="p">)</span>   
        
            

    <span class="c1"># Cropped X-axis limits</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: (float, float) Limits of pixels in x-direction.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Cropped Y-axis limits</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ylim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: (float, float) Limits of pixels in y-direction.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: Range of pixels in x-direction.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: Range of pixels in y-direction.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aspect_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: Aspect ratio of maps (dy / dx).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">array_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tuple: (int, int) Size of map in pixels&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">nunique</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">nunique</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">apply_outlier_to_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_outlier_to_all</span>
    
    <span class="nd">@apply_outlier_to_all</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">apply_outlier_to_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_apply_outlier_to_all</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_apply_outlier_to_all</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_outlier_to_all</span><span class="p">:</span>
            <span class="k">return</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_outlier_to_all</span> <span class="o">=</span> <span class="n">new_apply_outlier_to_all</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;apply_outlier_to_all&quot;</span><span class="p">,</span> <span class="n">new_apply_outlier_to_all</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">auto_scale_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_scale_value</span>
    
    <span class="nd">@auto_scale_value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">auto_scale_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_auto_scale_value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_auto_scale_value</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_scale_value</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_scale_value</span> <span class="o">=</span> <span class="n">new_auto_scale_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;auto_scale_value&quot;</span><span class="p">,</span> <span class="n">new_auto_scale_value</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">outlier_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: Method for predicting and clipping outliers.&quot;&quot;&quot;</span>        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outlier_method</span>

    <span class="nd">@outlier_method</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">outlier_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outlier_method</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outlier_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;outlier_method&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">negative_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: Method for negative handling.&quot;&quot;&quot;</span>        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_method</span>
 
    <span class="nd">@negative_method</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">negative_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_method</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_negative_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;negative_method&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_min_quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_min_quantile</span>
    
    <span class="nd">@data_min_quantile</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data_min_quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data_min_quantile</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_data_min_quantile</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_min_quantile</span><span class="p">:</span>
            <span class="k">return</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_min_quantile</span> <span class="o">=</span> <span class="n">new_data_min_quantile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;data_min_quantile&quot;</span><span class="p">,</span> <span class="n">new_data_min_quantile</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_max_quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_max_quantile</span>
    
    <span class="nd">@data_max_quantile</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data_max_quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data_max_quantile</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_data_max_quantile</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_max_quantile</span><span class="p">:</span>
            <span class="k">return</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_max_quantile</span> <span class="o">=</span> <span class="n">new_data_max_quantile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;data_max_quantile&quot;</span><span class="p">,</span> <span class="n">new_data_max_quantile</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_min_diff_quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_min_diff_quantile</span>
    
    <span class="nd">@data_min_diff_quantile</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data_min_diff_quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data_min_diff_quantile</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_data_min_diff_quantile</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_min_diff_quantile</span><span class="p">:</span>
            <span class="k">return</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_min_diff_quantile</span> <span class="o">=</span> <span class="n">new_data_min_diff_quantile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;data_min_diff_quantile&quot;</span><span class="p">,</span> <span class="n">new_data_min_diff_quantile</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_max_diff_quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_max_diff_quantile</span>
    
    <span class="nd">@data_max_diff_quantile</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data_max_diff_quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data_max_diff_quantile</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_data_max_diff_quantile</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_max_diff_quantile</span><span class="p">:</span>
            <span class="k">return</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_max_diff_quantile</span> <span class="o">=</span> <span class="n">new_data_max_diff_quantile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;data_max_diff_quantile&quot;</span><span class="p">,</span> <span class="n">new_data_max_diff_quantile</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">crop_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray: Boolean mask used to crop the raw data. True values will be used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crop_mask</span>
    
    <span class="nd">@crop_mask</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">crop_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_xlim</span><span class="p">,</span> <span class="n">new_ylim</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="o">=</span><span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_crop_mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">new_xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">new_xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">new_ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">new_ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="c1">#crop clipped_analyte_data based on self.crop_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_mask</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_mask</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_crop_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_field</span>
    
    <span class="nd">@current_field</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">current_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_field</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_field</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_field</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_field</span> <span class="o">=</span> <span class="n">new_field</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;processed_data&quot;</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">new_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if new_field is None, use first analyte field</span>
            <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">match_attribute</span><span class="p">(</span><span class="s1">&#39;data_type&#39;</span><span class="p">,</span><span class="s1">&#39;Analyte&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">negative_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;negative_method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outlier_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;outlier_method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;smoothing_method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_min_quantile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="s1">&#39;lower_bound&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_max_quantile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="s1">&#39;upper_bound&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_min_diff_quantile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="s1">&#39;diff_lower_bound&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_max_diff_quantile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="s1">&#39;diff_upper_bound&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use new_field</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">negative_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">new_field</span><span class="p">,</span> <span class="s1">&#39;negative_method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outlier_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">new_field</span><span class="p">,</span> <span class="s1">&#39;outlier_method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">new_field</span><span class="p">,</span> <span class="s1">&#39;smoothing_method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_min_quantile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">new_field</span><span class="p">,</span><span class="s1">&#39;lower_bound&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_max_quantile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">new_field</span><span class="p">,</span><span class="s1">&#39;upper_bound&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_min_diff_quantile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">new_field</span><span class="p">,</span><span class="s1">&#39;diff_lower_bound&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_max_diff_quantile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">new_field</span><span class="p">,</span><span class="s1">&#39;diff_upper_bound&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">notify_observers</span><span class="p">(</span><span class="s2">&quot;apply_process_to_all_data&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_field</span><span class="p">)</span>

    <span class="c1"># validation functions</span>
    <span class="k">def</span> <span class="nf">_is_valid_oulier_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates if a the method is a valid string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;quantile criteria&#39;</span><span class="p">,</span> <span class="s1">&#39;quantile and distance criteria&#39;</span><span class="p">,</span> <span class="s1">&#39;chauvenet criterion&#39;</span><span class="p">,</span> <span class="s1">&#39;log(n&gt;x) inflection&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="SampleObj.parse_field">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.parse_field">[docs]</a>
    <span class="k">def</span> <span class="nf">parse_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">field</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a field to symbol and mass.</span>

<span class="sd">        Separates an analyte field with a element symbol-mass name to its separate parts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field : str</span>
<span class="sd">            Field name to separate into symbol and mass.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str, int</span>
<span class="sd">            Returns the element symbol and mass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;([A-Za-z]+)(\d*)&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">match</span> <span class="k">else</span> <span class="n">field</span>
        <span class="n">mass</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">mass</span></div>


<div class="viewcode-block" id="SampleObj.add_columns">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.add_columns">[docs]</a>
    <span class="k">def</span> <span class="nf">add_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add one or more columns to the sample object.</span>

<span class="sd">        Adds one or more columns to `SampleObj.processed_data`. If a mask is provided,</span>
<span class="sd">        the data is placed in the correct rows based on the mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_type : str</span>
<span class="sd">            The type of data stored in the columns.</span>
<span class="sd">        column_names : str or list of str</span>
<span class="sd">            The name or names of the columns to add. If a column already exists, it will be overwritten.</span>
<span class="sd">        array : numpy.ndarray</span>
<span class="sd">            A 1D array (for single column) or 2D array (for multiple columns). The data to be added.</span>
<span class="sd">        mask : numpy.ndarray, optional</span>
<span class="sd">            A boolean mask that indicates which rows in the original data should be filled. If not provided,</span>
<span class="sd">            the length of `array` must match the height of `processed_data`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict or str</span>
<span class="sd">            Returns a message if a column is overwritten, or a dictionary with column names as keys</span>
<span class="sd">            and &quot;overwritten&quot; or &quot;added&quot; as values if multiple columns are added.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Valid types are given in `SampleObj._valid_data_types`.</span>
<span class="sd">        ValueError</span>
<span class="sd">            The number of columns in the array must match the length of `column_names` (if multiple columns are being added).</span>
<span class="sd">        ValueError</span>
<span class="sd">            The length of array must match the height of `processed_data` if no mask is provided.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a mask is provided, its length must match the height of `processed_data`, and the number of `True` values</span>
<span class="sd">            in the mask must match the number of rows in `array`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure column_names is a list, even if adding a single column</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">column_names</span><span class="p">]</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Convert 1D array to 2D for consistency</span>

        <span class="c1"># Check data type</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_data_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The (data_type) provided is not valid. Valid types include: &quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_data_types</span><span class="p">]))</span>

        <span class="c1"># Check if number of columns in array matches column_names</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of columns in (array) must match the number of (column_names).&quot;</span><span class="p">)</span>

        <span class="c1"># Check array length or mask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No mask, array length must match the height of processed_data</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of (array) must be the same as the height of the data frame.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mask provided, check its validity</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of (mask) must be the same as the number of rows in the data frame.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of rows in (array) must match the number of `True` values in the mask.&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Loop through each column</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_names</span><span class="p">):</span>
            <span class="c1"># Check if the column already exists</span>
            <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;overwritten&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;added&quot;</span>

            <span class="c1"># Create the new column array</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># No mask: directly use the array for this column</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Masked: fill a new column initialized with NaNs, then assign the masked rows</span>
                <span class="n">full_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">full_column</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_column</span>

            <span class="c1"># Set attributes for the newly added column</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;data_type&#39;</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Set quantile bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;lower_bound&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_lower_bound</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;upper_bound&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_upper_bound</span><span class="p">)</span>
            <span class="c1"># Set quantile bounds for differences</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;diff_lower_bound&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_difference_lower_bound</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;diff_upper_bound&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_difference_upper_bound</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span><span class="s1">&#39;label&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">create_label</span><span class="p">(</span><span class="n">column_name</span><span class="p">))</span>

            <span class="c1"># Set min and max unmasked values</span>
            <span class="n">amin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">column_name</span><span class="p">][</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">column_name</span><span class="p">][</span><span class="n">mask</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">,</span><span class="s1">&#39;Yc&#39;</span><span class="p">]:</span> <span class="c1"># do not round &#39;X&#39; and &#39;Y&#39; so full extent of map is viewable</span>
                <span class="n">amin</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">oround</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">toward</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">amax</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">oround</span><span class="p">(</span><span class="n">amax</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">toward</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span><span class="s1">&#39;plot_min&#39;</span><span class="p">,</span><span class="n">amin</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span><span class="s1">&#39;plot_max&#39;</span><span class="p">,</span><span class="n">amax</span><span class="p">)</span>

            <span class="c1"># Set additional attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;negative_method&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;outlier_method&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;smoothing_method&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;auto_scale&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="c1"># add probability axis associated with histograms</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;p_min&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="s1">&#39;p_max&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Return a message if a single column was added, or the result dictionary for multiple columns</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="SampleObj.create_label">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.create_label">[docs]</a>
    <span class="k">def</span> <span class="nf">create_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a default label for plotting</span>

<span class="sd">        Creates a default label for plotting </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column_name : _type_</span>
<span class="sd">            _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">data_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span><span class="s1">&#39;data_type&#39;</span><span class="p">)</span> 
        <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">match</span> <span class="n">data_type</span><span class="p">:</span>
            <span class="k">case</span> <span class="s1">&#39;Analyte&#39;</span> <span class="o">|</span> <span class="s1">&#39;Analyte (normalized)&#39;</span><span class="p">:</span> 
                <span class="n">symbol</span><span class="p">,</span> <span class="n">mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_field</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mass</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$^</span><span class="se">{{</span><span class="si">{</span><span class="n">mass</span><span class="si">}</span><span class="se">}}</span><span class="s2">$</span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span><span class="s1">&#39;units&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;Analyte&#39;</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># normalized analyte</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">$_N$ (</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">case</span> <span class="s1">&#39;Ratio&#39;</span> <span class="o">|</span> <span class="s1">&#39;Ratio (normalized)&#39;</span><span class="p">:</span>
                <span class="n">field_1</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; / &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">field_2</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; / &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">symbol_1</span><span class="p">,</span> <span class="n">mass_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_field</span><span class="p">(</span><span class="n">field_1</span><span class="p">)</span>
                <span class="n">symbol_2</span><span class="p">,</span> <span class="n">mass_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_field</span><span class="p">(</span><span class="n">field_2</span><span class="p">)</span>

                <span class="c1"># numerator</span>
                <span class="n">label_1</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">mass_1</span><span class="p">:</span> <span class="c1"># isotope</span>
                    <span class="n">label_1</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$^</span><span class="se">{{</span><span class="si">{</span><span class="n">mass_1</span><span class="si">}</span><span class="se">}}</span><span class="s2">$</span><span class="si">{</span><span class="n">symbol_1</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># element</span>
                    <span class="n">label_1</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">symbol_1</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="c1"># denominator</span>
                <span class="n">label_2</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">mass_2</span><span class="p">:</span> <span class="c1"># isotope</span>
                    <span class="n">label_2</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$^</span><span class="se">{{</span><span class="si">{</span><span class="n">mass_2</span><span class="si">}</span><span class="se">}}</span><span class="s2">$</span><span class="si">{</span><span class="n">symbol_2</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># element</span>
                    <span class="n">label_2</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">symbol_2</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;Ratio&#39;</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_1</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">label_2</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>   <span class="c1"># normalized ratio</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_1</span><span class="si">}</span><span class="s2">$_N$ / </span><span class="si">{</span><span class="n">label_2</span><span class="si">}</span><span class="s2">$_N$&quot;</span>
            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span><span class="s1">&#39;units&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="k">return</span> <span class="n">label</span></div>



<div class="viewcode-block" id="SampleObj.delete_column">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.delete_column">[docs]</a>
    <span class="k">def</span> <span class="nf">delete_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes a column and associated attributes from the AttributeDataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column_name : str</span>
<span class="sd">            Name of column to remove.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raises an error if the column is not a member of the AttributeDataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># Check if the column exists</span>
        <span class="k">if</span> <span class="n">column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2"> does not exist in the DataFrame.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Remove the column from the DataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Remove associated attributes, if any</span>
        <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">column_attributes</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">column_attributes</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span></div>


<div class="viewcode-block" id="SampleObj.reset_resolution">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.reset_resolution">[docs]</a>
    <span class="k">def</span> <span class="nf">reset_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resets dx and dy to initial values</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_aspect_ratio_controls</span><span class="p">()</span></div>


<div class="viewcode-block" id="SampleObj.swap_xy">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.swap_xy">[docs]</a>
    <span class="k">def</span> <span class="nf">swap_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Swaps data in a SampleObj.&quot;&quot;&quot;</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">is_swapped</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_swapped</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_swapped</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_swap_xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_swap_xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span>

        <span class="c1"># swap orientation of original dx and dy to be consistent with X and Y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dx</span></div>


    <span class="k">def</span> <span class="nf">_swap_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Swaps X and Y of a dataframe</span>

<span class="sd">        Swaps coordinates for all maps in sample dataframe.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">            data frame to swap X and Y coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xtemp</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xtemp</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;Yc&#39;</span><span class="p">,</span><span class="s1">&#39;Xc&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="SampleObj.update_resolution">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.update_resolution">[docs]</a>
    <span class="k">def</span> <span class="nf">update_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates DX and DY for a dataframe</span>

<span class="sd">        Recalculates X and Y for a dataframe when the user changes the value of</span>
<span class="sd">        pixel dimensions Dx or Dy</span>

<span class="sd">        Parameter</span>
<span class="sd">        ---------</span>
<span class="sd">        axis : str</span>
<span class="sd">            Indicates axis to update resolution, &#39;x&#39; or &#39;y&#39;.</span>
<span class="sd">        value: float</span>
<span class="sd">            Holds the new value that is used to update.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># update resolution based on user change</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span></div>


<div class="viewcode-block" id="SampleObj.swap_resolution">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.swap_resolution">[docs]</a>
    <span class="k">def</span> <span class="nf">swap_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Swaps DX and DY for a dataframe, updates X and Y</span>

<span class="sd">        Recalculates X and Y for a dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>  
        <span class="n">X</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>

        <span class="n">Xp</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">Yp</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="n">dx</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">*</span><span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="o">*</span><span class="n">Y</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">*</span><span class="n">Xp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;Yc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="o">*</span><span class="n">Yp</span></div>


<div class="viewcode-block" id="SampleObj.reset_crop">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.reset_crop">[docs]</a>
    <span class="k">def</span> <span class="nf">reset_crop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the data to the original bounds.</span>

<span class="sd">        Reseting the data to the original bounds results in deleting progress on analyses,</span>
<span class="sd">        computations, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># bring up dialog asking if user wishes to proceed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">confirm_reset</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="c1"># Need to update to keep computed columns?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_data</span><span class="p">()</span></div>


<div class="viewcode-block" id="SampleObj.compute_ratio">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.compute_ratio">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analyte_1</span><span class="p">,</span> <span class="n">analyte_2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute a ratio field from two analytes.</span>

<span class="sd">        Ratios are computed on the processed_data, after negative handling, but before autoscaling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        analyte_1 : str</span>
<span class="sd">            Analyte field to be used as numerator of ratio.</span>
<span class="sd">        analyte_2 : str</span>
<span class="sd">            Analyte field to be used as denominator of ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a mask where both analytes are positive</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">analyte_1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">analyte_2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Calculate the ratio and set invalid values to NaN</span>
        <span class="n">ratio_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">analyte_1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">analyte_2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Generate the ratio column name</span>
        <span class="n">ratio_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">analyte_1</span><span class="si">}</span><span class="s1"> / </span><span class="si">{</span><span class="n">analyte_2</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_columns</span><span class="p">(</span><span class="s1">&#39;Ratio&#39;</span><span class="p">,</span><span class="n">ratio_name</span><span class="p">,</span><span class="n">ratio_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">ratio_name</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleObj.cluster_data">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.cluster_data">[docs]</a>
    <span class="k">def</span> <span class="nf">cluster_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clusters data for use with data preprocessing</span>

<span class="sd">        _extended_summary_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Clustering</span>
        <span class="c1"># ------------------</span>
        <span class="c1"># Select columns where &#39;data_type&#39; attribute is &#39;Analyte&#39;</span>
        <span class="n">analyte_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;data_type&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Analyte&#39;</span><span class="p">)</span> 
            <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">))</span> <span class="p">]</span>

        <span class="c1"># Extract the analyte data</span>
        <span class="n">analyte_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="n">analyte_columns</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># Mask invalid data (e.g., NaN, inf)</span>
        <span class="n">mask_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">analyte_data</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Filter out the invalid data</span>
        <span class="n">analyte_data</span> <span class="o">=</span> <span class="n">analyte_data</span><span class="p">[</span><span class="n">mask_valid</span><span class="p">]</span>

        <span class="c1"># Calculate percentiles for central bulk of the valid data</span>
        <span class="n">lower_percentile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">analyte_data</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">upper_percentile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">analyte_data</span><span class="p">,</span> <span class="mf">98.75</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Create a mask for central bulk of the data (within the range of percentiles)</span>
        <span class="n">mask_central</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">analyte_data</span> <span class="o">&gt;=</span> <span class="n">lower_percentile</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">analyte_data</span> <span class="o">&lt;=</span> <span class="n">upper_percentile</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Data for optimal cluster calculation: central 97.5%</span>
        <span class="c1"># Determine the optimal number of clusters using filtered_data</span>
        <span class="n">optimal_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_optimal_clusters</span><span class="p">(</span><span class="n">analyte_data</span><span class="p">[</span><span class="n">mask_central</span><span class="p">])</span>

        <span class="c1"># Fit KMeans with the optimal number of clusters</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">optimal_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">analyte_data</span><span class="p">)</span>

        <span class="c1"># Create a full-sized vector with NaN values where mask is False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">mask_valid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">mask_valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_labels</span></div>


        <span class="c1"># if DEBUG_PLOT:</span>
        <span class="c1">#     # Reshape the full_labels array based on unique X and Y values</span>
        <span class="c1">#     x_unique = self.raw_data[&#39;Xc&#39;].nunique()  # Assuming &#39;X&#39; is a column in raw_data</span>
        <span class="c1">#     y_unique = self.raw_data[&#39;Yc&#39;].nunique()  # Assuming &#39;Y&#39; is a column in raw_data</span>

        <span class="c1">#     # Ensure the reshaped array has the same shape as the spatial grid</span>
        <span class="c1">#     reshaped_labels = np.reshape(self.cluster_labels, (y_unique, x_unique), order=&#39;F&#39;)</span>

        <span class="c1">#     # Plot using imshow</span>
        <span class="c1">#     fig, ax1 = plt.subplots() </span>
        <span class="c1">#     cax = ax1.imshow(reshaped_labels, cmap=&#39;viridis&#39;, interpolation=&#39;none&#39;)</span>
        <span class="c1">#     cbar = fig.colorbar(cax, label=&#39;Cluster Labels&#39;, ax=ax1, orientation=&#39;horizontal&#39;)</span>
        <span class="c1">#     ax1.set_title(&#39;Cluster Labels with NaN Handling&#39;)</span>
        <span class="c1">#     ax1.set_xlabel(&#39;X&#39;)</span>
        <span class="c1">#     ax1.set_ylabel(&#39;Y&#39;)</span>
        <span class="c1">#     fig.show()</span>

<div class="viewcode-block" id="SampleObj.prep_data">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.prep_data">[docs]</a>
    <span class="k">def</span> <span class="nf">prep_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies adjustments to data data prior to analyses and plotting.</span>

<span class="sd">        This method applies a workflow to adjust data to limit the number of data that are otherwise</span>
<span class="sd">        unusable due to incorrect calibrations, particularly for low and high element concentration regions.</span>
<span class="sd">        </span>
<span class="sd">        Data are adjusted according to the proceedure:</span>
<span class="sd">        | Determine optimal number of clusters and use it to classify the data using kmeans.</span>
<span class="sd">        | Transform each cluster, by handling negative data.  The method of negative handling is set by ``MainWindow.comboBoxNegativeMethod.currentText()``.</span>
<span class="sd">        | Compute ratios not imported (i.e., not in raw_data).</span>
<span class="sd">        | Determine outliers and limit their impact on analyses by clipping/autoscaling</span>

<span class="sd">        These calculations start from the cropped data, but do not include chemical, polygonal, or cluster filtering.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            processed_data has not yet been initialized.  processed_data should be created when the sample is initialized and prep_data is</span>
<span class="sd">            run for the first time.</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="n">attribute_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">analyte_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ratio_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">field</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
            <span class="c1"># Select columns where &#39;data_type&#39; attribute is &#39;Analyte&#39;</span>
            <span class="n">analyte_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">match_attributes</span><span class="p">({</span><span class="s1">&#39;data_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Analyte&#39;</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
            <span class="c1"># analyte_columns = self.raw_data.match_attribute(&#39;data_type&#39;, &#39;Analyte&#39;)</span>
            <span class="c1"># analyte_columns = [col for col in analyte_columns if self.raw_data.get_attribute(col, &#39;use&#39;) is True]</span>
            <span class="c1"># analyte_columns = [col for col in self.raw_data.columns if (self.raw_data.get_attribute(col, &#39;data_type&#39;) == &#39;Analyte&#39;) </span>
                <span class="c1"># and (self.raw_data.get_attribute(col, &#39;use&#39;) is not None</span>
                <span class="c1"># and self.raw_data.get_attribute(col, &#39;use&#39;)) ]</span>

            <span class="c1"># Select columns where &#39;data_type&#39; attribute is &#39;Ratio&#39;</span>
            <span class="n">ratio_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">match_attributes</span><span class="p">({</span><span class="s1">&#39;data_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Ratio&#39;</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
            <span class="c1"># ratio_columns = self.raw_data.match_attribute(&#39;data_type&#39;, &#39;Ratio&#39;)</span>
            <span class="c1"># ratio_columns = [col for col in ratio_columns if self.raw_data.get_attribute(col, &#39;use&#39;) is True]</span>
            <span class="c1"># ratio_columns = [col for col in self.raw_data.columns if (self.raw_data.get_attribute(col, &#39;data_type&#39;) == &#39;Ratio&#39;) </span>
            <span class="c1">#     and (self.raw_data.get_attribute(col, &#39;use&#39;) is not None</span>
            <span class="c1">#     and self.raw_data.get_attribute(col, &#39;use&#39;)) ]</span>

            <span class="n">columns</span> <span class="o">=</span> <span class="n">analyte_columns</span> <span class="o">+</span> <span class="n">ratio_columns</span>

            <span class="c1"># this needs to be updated to handle different negative handling methods for different fields.</span>
            <span class="c1"># may need to create a copy of processed_data overwriting with raw_data</span>
            <span class="n">negative_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">analyte_columns</span><span class="p">,</span> <span class="s1">&#39;negative_method&#39;</span><span class="p">,</span> <span class="n">negative_method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">field</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;processed_data&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;processed_data has not yet been defined.&quot;</span><span class="p">)</span>

        <span class="c1"># Handle negative values</span>
        <span class="c1"># ----------------------</span>
        <span class="c1"># for col in analyte_columns:</span>
        <span class="c1">#     if col not in self.raw_data.columns:</span>
        <span class="c1">#         continue</span>

        <span class="c1">#     for idx in np.unique(self.cluster_labels):</span>
        <span class="c1">#         if np.isnan(idx):</span>
        <span class="c1">#             continue</span>
        <span class="c1">#         cluster_mask = self.cluster_labels == idx</span>
        <span class="c1">#         print(f&quot;{(col, idx)} before: {sum(self.processed_data[col] &lt; 0)}, {sum(self.processed_data[col][cluster_mask] &lt; 0)}&quot;)</span>
        <span class="c1">#         transformed_data = self.transform_array(self.processed_data[col][cluster_mask],self.processed_data.get_attribute(col,&#39;negative_method&#39;))</span>
        <span class="c1">#         self.processed_data.loc[cluster_mask, col] = transformed_data</span>
        <span class="c1">#         print(f&quot;{(col, idx)} after : {sum(self.processed_data[col] &lt; 0)}, {sum(self.processed_data[col][cluster_mask] &lt; 0)}, {sum(transformed_data &lt; 0)}&quot;)</span>

        <span class="c1"># Compute ratios not included in raw_data</span>
        <span class="c1"># ---------------------------------------</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">attribute_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">ratios</span> <span class="o">=</span> <span class="n">attribute_df</span><span class="o">.</span><span class="n">columns</span><span class="p">[(</span><span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;Ratio&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()]</span>

            <span class="n">ratios_not_in_raw_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ratios</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ratio_columns</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ratios_not_in_raw_data</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="n">col</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_ratio</span><span class="p">(</span><span class="n">analyte_1</span><span class="p">,</span> <span class="n">analyte_2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">ratios_not_in_raw_data</span><span class="p">,</span> <span class="s1">&#39;lower_bound&#39;</span><span class="p">,</span> <span class="n">attribute_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;lower_bound&#39;</span><span class="p">,</span> <span class="n">ratios_not_in_raw_data</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">ratios_not_in_raw_data</span><span class="p">,</span> <span class="s1">&#39;upper_bound&#39;</span><span class="p">,</span> <span class="n">attribute_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;upper_bound&#39;</span><span class="p">,</span> <span class="n">ratios_not_in_raw_data</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">ratios_not_in_raw_data</span><span class="p">,</span> <span class="s1">&#39;diff_upper_bound&#39;</span><span class="p">,</span> <span class="n">attribute_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;diff_upper_bound&#39;</span><span class="p">,</span> <span class="n">ratios_not_in_raw_data</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">ratios_not_in_raw_data</span><span class="p">,</span> <span class="s1">&#39;diff_lower_bound&#39;</span><span class="p">,</span> <span class="n">attribute_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;diff_lower_bound&#39;</span><span class="p">,</span> <span class="n">ratios_not_in_raw_data</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">ratios_not_in_raw_data</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="n">attribute_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="n">ratios_not_in_raw_data</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">ratios_not_in_raw_data</span><span class="p">,</span> <span class="s1">&#39;auto_scale&#39;</span><span class="p">,</span> <span class="n">attribute_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;auto_scale&#39;</span><span class="p">,</span> <span class="n">ratios_not_in_raw_data</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>


        <span class="c1"># Clip outliers / autoscale the data</span>
        <span class="c1"># ------------------</span>
        <span class="c1"># loop over all fields</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">(</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;data_type&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;coordinate&#39;</span><span class="p">):</span>

            <span class="n">lq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;lower_bound&#39;</span><span class="p">)</span>
            <span class="n">uq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;upper_bound&#39;</span><span class="p">)</span>
            <span class="c1"># skip is autoscale is False for column</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;autoscale&#39;</span><span class="p">):</span>
                <span class="c1">#clip data using ub and lb</span>
                <span class="n">lq_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">lq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">uq_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">uq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">lq_val</span><span class="p">,</span> <span class="n">uq_val</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">d_lq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;diff_lower_bound&#39;</span><span class="p">)</span>
            <span class="n">d_uq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;diff_upper_bound&#39;</span><span class="p">)</span>

            <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">):</span>
                <span class="k">case</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
                    <span class="n">compositional</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">max_val</span> <span class="o">=</span> <span class="mf">1e6</span>
                    <span class="n">shift_percentile</span> <span class="o">=</span> <span class="mi">90</span>
                <span class="k">case</span> <span class="s1">&#39;cps&#39;</span><span class="p">:</span>
                    <span class="n">compositional</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">max_val</span> <span class="o">=</span> <span class="mf">1e6</span>
                    <span class="n">shift_percentile</span> <span class="o">=</span> <span class="mi">90</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="n">compositional</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">max_val</span> <span class="o">=</span> <span class="mf">1e6</span>
                    <span class="n">shift_percentile</span> <span class="o">=</span> <span class="mi">90</span>

            <span class="c1"># Apply robust outlier detection to each cluster</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">):</span>
                <span class="n">cluster_mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span>

                <span class="n">transformed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clip_outliers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">cluster_mask</span><span class="p">],</span> <span class="n">lq</span><span class="p">,</span> <span class="n">uq</span><span class="p">,</span> <span class="n">d_lq</span><span class="p">,</span> <span class="n">d_uq</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cluster_mask</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_data</span>

                <span class="n">transformed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantile_and_difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">cluster_mask</span><span class="p">],</span> <span class="n">lq</span><span class="p">,</span> <span class="n">uq</span><span class="p">,</span> <span class="n">d_lq</span><span class="p">,</span> <span class="n">d_uq</span><span class="p">,</span> <span class="n">compositional</span><span class="p">,</span> <span class="n">max_val</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cluster_mask</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_data</span>

        
        <span class="c1"># Compute special fields?</span>
        <span class="c1"># -----------------------</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="s1">&#39;label&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">create_label</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
            
            <span class="c1"># Set min and max unmasked values</span>
            <span class="n">amin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
            <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">,</span><span class="s1">&#39;Yc&#39;</span><span class="p">]:</span> <span class="c1"># do not round &#39;X&#39; and &#39;Y&#39; so full extent of map is viewable</span>
                <span class="n">amin</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">oround</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">toward</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">amax</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">oround</span><span class="p">(</span><span class="n">amax</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">toward</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="s1">&#39;plot_min&#39;</span><span class="p">,</span><span class="n">amin</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="s1">&#39;plot_max&#39;</span><span class="p">,</span><span class="n">amax</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleObj.k_optimal_clusters">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.k_optimal_clusters">[docs]</a>
    <span class="k">def</span> <span class="nf">k_optimal_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">max_clusters</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predicts the optimal number of clusters.</span>

<span class="sd">        Predicts the optimal number of k-means clusters using the elbow method based on the within-cluster sum of squares (WCSS):</span>

<span class="sd">        .. math::</span>
<span class="sd">            WCSS = \\sum_{i=1}^k \\sum_{x \\in C_i} (x - \\mu_i)^2</span>

<span class="sd">        The optimal number of clusters is determined by selecting the k-value corresponding to the maximum value of the second derivative of WCSS.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Data used in clustering. Make sure it has NaN and inf values removed.</span>
<span class="sd">        max_clusters : int, optional</span>
<span class="sd">            Computes cluster results from 1 to ``max_clusters``, by default 10.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The optimal number of k-means clusters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inertia</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># clip outliers and make entirely positive</span>
        <span class="n">percentile</span> <span class="o">=</span> <span class="mf">2.5</span>
        <span class="n">min_pos</span> <span class="o">=</span> <span class="mf">1e-2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># Find the minimum positive value in the column</span>
            <span class="n">col_min_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">min_threshold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">col_min_pos</span><span class="p">,</span> <span class="n">min_pos</span><span class="p">)</span>  <span class="c1"># Choose the larger of min positive or 0.01</span>

            <span class="c1"># Set all values less than the threshold to the threshold value</span>
            <span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_threshold</span><span class="p">,</span> <span class="n">min_threshold</span><span class="p">,</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

        <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">percentile</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">100</span><span class="o">-</span><span class="n">percentile</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Clip values to the 5th and 95th percentiles per column</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">))</span>
        
        <span class="c1"># Perform KMeans for cluster numbers from 1 to max_clusters</span>
        <span class="k">for</span> <span class="n">n_clusters</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_clusters</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">inertia</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">inertia_</span><span class="p">)</span>  <span class="c1"># Record the inertia (sum of squared distances)</span>
        
        <span class="c1"># Calculate second-order difference (second derivative)</span>
        <span class="n">second_derivative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">inertia</span><span class="p">))</span>

        <span class="c1"># Identify the elbow point</span>
        <span class="c1"># add 2 to the maximum index to obtain the optimal number of clusters,</span>
        <span class="c1"># 1 because it starts at 0 and 1 because it is the second derivative</span>
        <span class="n">optimal_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">second_derivative</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># Example heuristic</span>

        <span class="c1"># if DEBUG_PLOT:</span>
        <span class="c1">#     # Plot inertia</span>
        <span class="c1">#     fig, ax1 = plt.subplots()</span>

        <span class="c1">#     ax1.plot(range(1, max_clusters+1), inertia, marker=&#39;o&#39;, color=&#39;b&#39;, label=&#39;Inertia&#39;)</span>
        <span class="c1">#     ax1.set_xlabel(&#39;Number of clusters&#39;)</span>
        <span class="c1">#     ax1.set_ylabel(&#39;Inertia&#39;, color=&#39;b&#39;)</span>
        <span class="c1">#     ax1.tick_params(axis=&#39;y&#39;, labelcolor=&#39;b&#39;)</span>
        <span class="c1">#     ax1.set_title(&#39;Elbow Method for Optimal Clusters&#39;)</span>
        <span class="c1">#     ax1.axvline(x=optimal_k, linestyle=&#39;--&#39;, color=&#39;r&#39;, label=f&#39;Elbow at k={optimal_k}&#39;)</span>


        <span class="c1">#     # Create a secondary y-axis to plot the second derivative</span>
        <span class="c1">#     ax2 = ax1.twinx()</span>
        <span class="c1">#     ax2.plot(range(2, max_clusters), second_derivative, marker=&#39;x&#39;, color=&#39;r&#39;, label=&#39;2nd Derivative&#39;)</span>
        <span class="c1">#     ax2.set_ylabel(&#39;2nd Derivative&#39;, color=&#39;r&#39;)</span>
        <span class="c1">#     ax2.tick_params(axis=&#39;y&#39;, labelcolor=&#39;r&#39;)</span>

        <span class="c1">#     self.logger.print(f&quot;Second derivative of inertia: {second_derivative}&quot;)</span>
        <span class="c1">#     self.logger.print(f&quot;Optimal number of clusters: {optimal_k}&quot;)</span>

        <span class="k">return</span> <span class="n">optimal_k</span></div>



<div class="viewcode-block" id="SampleObj.clip_outliers">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.clip_outliers">[docs]</a>
    <span class="k">def</span> <span class="nf">clip_outliers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">outlier_method</span><span class="p">,</span> <span class="n">pl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dpl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dpu</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attempts to remove outliers to by a method selected by the user.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array : numpy.ndarray</span>
<span class="sd">            Data vector</span>
<span class="sd">        outlier_method : str</span>
<span class="sd">            Method for removing outliers</span>
<span class="sd">        pl : float, optional</span>
<span class="sd">            Lower percentile bound required by selected methods</span>
<span class="sd">        pu : float, optional</span>
<span class="sd">            Upper percentile bound required by selected methods</span>
<span class="sd">        dpl : float, optional</span>
<span class="sd">            Lower percentile bound for distances required by selected methods</span>
<span class="sd">        dpu : float, optional</span>
<span class="sd">            Upper percentile bound for distances required by selected methods</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Clipped data vector</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">t_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

        <span class="k">match</span> <span class="n">outlier_method</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">case</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">t_array</span>

            <span class="k">case</span> <span class="s1">&#39;quantile criteria&#39;</span><span class="p">:</span>
                <span class="n">ql</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">qu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">t_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="n">qu</span><span class="p">)</span>
                
            <span class="k">case</span> <span class="s1">&#39;quantile and distance criteria&#39;</span><span class="p">:</span>
                <span class="n">t_array</span> <span class="o">=</span> <span class="n">quantile_and_difference</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">pu</span><span class="p">,</span> <span class="n">dpl</span><span class="p">,</span> <span class="n">dpu</span><span class="p">,</span> <span class="n">compositional</span><span class="p">,</span> <span class="n">max_val</span><span class="p">)</span>
            <span class="k">case</span> <span class="s1">&#39;chauvenet criterion&#39;</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">chauvenet_criterion</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">t_array</span>

                <span class="n">min_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">t_array</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">max_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">t_array</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">t_array</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t_array</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">)]</span> <span class="o">=</span> <span class="n">min_value</span>
                <span class="n">t_array</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t_array</span> <span class="o">&gt;</span> <span class="n">max_value</span><span class="p">)]</span> <span class="o">=</span> <span class="n">max_value</span>

            <span class="k">case</span> <span class="s1">&#39;log(n&gt;x) inflection&#39;</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">t_array</span></div>


<div class="viewcode-block" id="SampleObj.transform_array">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.transform_array">[docs]</a>
    <span class="k">def</span> <span class="nf">transform_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">negative_method</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Negative and zero handling with clustering for noise detection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array : numpy.ndarray</span>
<span class="sd">            Input data</span>
<span class="sd">        negative_method : str</span>
<span class="sd">            Method for handling negative values</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Transformed data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">match</span> <span class="n">negative_method</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">case</span> <span class="s1">&#39;ignore negatives&#39;</span><span class="p">:</span>
                <span class="c1"># do nothing, the values remain unchanged</span>
                <span class="n">t_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
                <span class="n">t_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t_array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="k">case</span> <span class="s1">&#39;minimum positive&#39;</span><span class="p">:</span>
                <span class="c1"># shift all negative values to be a minimum value</span>
                <span class="n">min_positive_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">t_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">array</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_positive_value</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>

            <span class="k">case</span> <span class="s1">&#39;gradual shift&#39;</span><span class="p">:</span>
                <span class="c1"># Handle multidimensional case (2D array)</span>
                <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.0001</span>
                    <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">t_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_val</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> 
                                    <span class="p">(</span><span class="n">max_val</span> <span class="o">*</span> <span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">),</span>
                                    <span class="n">array</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># 1D array case</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.0001</span>
                    <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
                    <span class="n">t_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">*</span> <span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span> <span class="k">if</span> <span class="n">min_val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

            <span class="k">case</span> <span class="s1">&#39;yeo-johnson transform&#39;</span><span class="p">:</span>
                <span class="n">t_array</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">yeojohnson</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t_array</span></div>


<div class="viewcode-block" id="SampleObj.update_norm">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.update_norm">[docs]</a>
    <span class="k">def</span> <span class="nf">update_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the norm of the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_id : str</span>
<span class="sd">            Sample identifier</span>
<span class="sd">        norm : str, optional</span>
<span class="sd">            Data scale method ``linear`` or ``log``, by default None</span>
<span class="sd">        field : str, optional</span>
<span class="sd">            Field to change the norm, by default None</span>
<span class="sd">        update : bool, optional</span>
<span class="sd">            Update the scale information of the data, by default False</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#if normalising single analyte</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#if normalising all analytes in sample</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">match_attribute</span><span class="p">(</span><span class="s1">&#39;data_type&#39;</span><span class="p">,</span><span class="s1">&#39;Analyte&#39;</span><span class="p">),</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span><span class="n">norm</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="p">(</span><span class="n">field</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleObj.get_map_data">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.get_map_data">[docs]</a>
    <span class="k">def</span> <span class="nf">get_map_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">field_type</span><span class="o">=</span><span class="s1">&#39;Analyte&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">processed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves and processes the mapping data for the given sample and analytes</span>

<span class="sd">        The method also updates certain parameters in the analyte data frame related to scaling.</span>
<span class="sd">        Based on the plot type, this method internally calls the appropriate plotting functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field : str</span>
<span class="sd">            Name of field to plot. By default `None`.</span>
<span class="sd">        field_type : str, optional</span>
<span class="sd">            Type of field to plot. Types include &#39;Analyte&#39;, &#39;Ratio&#39;, &#39;PCA&#39;, &#39;Cluster&#39;, &#39;Cluster score&#39;,</span>
<span class="sd">            &#39;Special&#39;, &#39;Computed&#39;. By default `&#39;Analyte&#39;`</span>
<span class="sd">        norm : str</span>
<span class="sd">            Scale data as linear, log, etc. based on stored norm.  If scale_data is `False`, the</span>
<span class="sd">            data are returned with a linear scale.  By default `False`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            Processed data for plotting. This is only returned if analysis_type is not &#39;laser&#39; or &#39;hist&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----begin debugging----</span>
        <span class="c1"># print(&#39;[get_map_data] sample_id: &#39;+sample_id+&#39;   field_type: &#39;+field_type+&#39;   field: &#39;+field)</span>
        <span class="c1"># ----end debugging----</span>

        <span class="c1"># if sample_id != self.sample_id:</span>
        <span class="c1">#     #axis mask is not used when plot analytes of a different sample</span>
        <span class="c1">#     crop_mask  = np.ones_like( self.raw_data[&#39;Xc&#39;], dtype=bool)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     crop_mask = self.data[self.sample_id][&#39;crop_mask&#39;]</span>
        
        <span class="c1"># retrieve axis mask for that sample</span>
        <span class="c1">#crop_mask = self.crop_mask</span>
        
        <span class="c1">#crop plot if filter applied</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[[</span><span class="s1">&#39;Xc&#39;</span><span class="p">,</span><span class="s1">&#39;Yc&#39;</span><span class="p">]]</span>

        <span class="k">match</span> <span class="n">field_type</span><span class="p">:</span>
            <span class="k">case</span> <span class="s1">&#39;Analyte&#39;</span> <span class="o">|</span> <span class="s1">&#39;Analyte (normalized)&#39;</span><span class="p">:</span>
                <span class="c1"># unnormalized</span>
                <span class="k">if</span> <span class="n">processed</span><span class="p">:</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

                <span class="c1">#norm = self.processed_data.get_attribute(field, &#39;norm&#39;)</span>
                
                <span class="c1">#perform scaling for groups of analytes with same norm parameter</span>
                <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;logit&#39;</span><span class="p">:</span>
                    <span class="c1"># Handle division by zero and NaN values</span>
                    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                
                <span class="c1"># normalize</span>
                <span class="k">if</span> <span class="s1">&#39;normalized&#39;</span> <span class="ow">in</span> <span class="n">field_type</span><span class="p">:</span>
                    <span class="n">refval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_chem</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">refval</span>

            <span class="k">case</span> <span class="s1">&#39;Ratio&#39;</span> <span class="o">|</span> <span class="s1">&#39;Ratio (normalized)&#39;</span><span class="p">:</span>
                <span class="n">field_1</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; / &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">field_2</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; / &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># unnormalized</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                
                <span class="c1"># normalize</span>
                <span class="k">if</span> <span class="s1">&#39;normalized&#39;</span> <span class="ow">in</span> <span class="n">field_type</span><span class="p">:</span>
                    <span class="n">refval_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_chem</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field_1</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
                    <span class="n">refval_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_chem</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field_2</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">refval_2</span> <span class="o">/</span> <span class="n">refval_1</span><span class="p">)</span>

                <span class="c1">#get norm value</span>
                <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;logit&#39;</span><span class="p">:</span>
                    <span class="c1"># Handle division by zero and NaN values</span>
                    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span><span class="c1">#&#39;PCA score&#39; | &#39;Cluster&#39; | &#39;Cluster score&#39; | &#39;Special&#39; | &#39;Computed&#39;:</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            
        <span class="c1"># ----begin debugging----</span>
        <span class="c1"># print(df.columns)</span>
        <span class="c1"># ----end debugging----</span>
        <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="SampleObj.get_processed_data">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.get_processed_data">[docs]</a>
    <span class="k">def</span> <span class="nf">get_processed_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets the processed data for analysis</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            Filtered data frame </span>
<span class="sd">        bool</span>
<span class="sd">            Analytes included from processed data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_id</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># return normalised, filtered data with that will be used for analysis</span>
        <span class="c1">#use_analytes = self.data[self.sample_id][&#39;Analyte_info&#39;].loc[(self.data[self.sample_id][&#39;Analyte_info&#39;][&#39;use&#39;]==True), &#39;Analytes&#39;].values</span>
        <span class="n">use_analytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">match_attributes</span><span class="p">({</span><span class="s1">&#39;data_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Analyte&#39;</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="n">use_analytes</span><span class="p">]</span>

        <span class="c1">#perform scaling for groups of analytes with same norm parameter</span>
        <span class="k">for</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;logit&#39;</span><span class="p">,</span> <span class="s1">&#39;symlog&#39;</span><span class="p">]:</span>
            <span class="n">analyte_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">match_attributes</span><span class="p">({</span><span class="s1">&#39;data_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Analyte&#39;</span><span class="p">,</span> <span class="s1">&#39;use&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">:</span> <span class="n">norm</span><span class="p">})</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">analyte_set</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">tmp_array</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">analyte_set</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                <span class="c1"># np.nanlog handles NaN value</span>
                <span class="n">df</span><span class="p">[</span><span class="n">analyte_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tmp_array</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">tmp_array</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;symlog&#39;</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">analyte_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tmp_array</span><span class="p">),</span> <span class="n">symlog</span><span class="p">(</span><span class="n">tmp_array</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;logit&#39;</span><span class="p">:</span>
                <span class="c1"># Handle division by zero and NaN values</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">analyte_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tmp_array</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">tmp_array</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="n">tmp_array</span><span class="p">)))</span>

        <span class="c1"># Combine the two masks to create a final mask</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        
        <span class="c1"># mask nan values and add to self.mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>  <span class="o">&amp;</span> <span class="n">nan_mask</span><span class="o">.</span><span class="n">values</span>

        <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">use_analytes</span></div>

    
    <span class="c1"># extracts data for scatter plot</span>
<div class="viewcode-block" id="SampleObj.get_vector">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.get_vector">[docs]</a>
    <span class="k">def</span> <span class="nf">get_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_type</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">processed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a dictionary of values for plotting</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with array and additional relevant plot data, contains</span>
<span class="sd">            &#39;field&#39;, &#39;type&#39;, &#39;label&#39;, and &#39;array&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initialize dictionary</span>
        <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">field_type</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value_dict</span>

        <span class="c1"># add label</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_dict</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_dict</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_dict</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_dict</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; (&#39;</span> <span class="o">+</span> <span class="n">unit</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

        <span class="c1"># add array</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map_data</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span> <span class="n">field_type</span><span class="o">=</span><span class="n">field_type</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">processed</span><span class="o">=</span><span class="n">processed</span><span class="p">)</span>
        <span class="n">value_dict</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">value_dict</span></div>


    <span class="c1"># def outlier_detection(self, lq=0.0005, uq=99.5, d_lq=9.95 , d_uq=99):</span>
    <span class="c1">#     &quot;&quot;&quot;_summary_</span>

    <span class="c1">#     _extended_summary_</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     data : _type_</span>
    <span class="c1">#         _description_</span>
    <span class="c1">#     lq : float, optional</span>
    <span class="c1">#         _description_, by default 0.0005</span>
    <span class="c1">#     uq : float, optional</span>
    <span class="c1">#         _description_, by default 99.5</span>
    <span class="c1">#     d_lq : float, optional</span>
    <span class="c1">#         _description_, by default 9.95</span>
    <span class="c1">#     d_uq : int, optional</span>
    <span class="c1">#         _description_, by default 99</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     _type_</span>
    <span class="c1">#         _description_</span>
    <span class="c1">#     &quot;&quot;&quot;        </span>
    <span class="c1">#     # Ensure data is a numpy array</span>
    <span class="c1">#     data = np.array(data)</span>

    <span class="c1">#     # Shift values to positive concentrations</span>
    <span class="c1">#     v0 = np.nanmin(data, axis=0) - 0.001</span>
    <span class="c1">#     data_shifted = np.log10(data - v0)</span>

    <span class="c1">#     # Calculate required quantiles and differences</span>
    <span class="c1">#     lq_val = np.nanpercentile(data_shifted, lq, axis=0)</span>
    <span class="c1">#     uq_val = np.nanpercentile(data_shifted, uq, axis=0)</span>
    <span class="c1">#     sorted_indices = np.argsort(data_shifted, axis=0)</span>
    <span class="c1">#     sorted_data = np.take_along_axis(data_shifted, sorted_indices, axis=0)</span>


    <span class="c1">#     diff_sorted_data = np.diff(sorted_data, axis=0)</span>
    <span class="c1">#     # Adding a 0 to the beginning of each column to account for the reduction in size by np.diff</span>
    <span class="c1">#     diff_sorted_data = np.insert(diff_sorted_data, 0, 0, axis=0)</span>
    <span class="c1">#     diff_array_uq_val = np.nanpercentile(diff_sorted_data, d_uq, axis=0)</span>
    <span class="c1">#     diff_array_lq_val = np.nanpercentile(diff_sorted_data, d_lq, axis=0)</span>
    <span class="c1">#     upper_cond = (sorted_data &gt; uq_val) &amp; (diff_sorted_data &gt; diff_array_uq_val)</span>

    <span class="c1">#     # Initialize arrays for results</span>
    <span class="c1">#     clipped_data = np.copy(sorted_data)</span>

    <span class="c1">#     # Upper bound outlier filter</span>
    <span class="c1">#     for col in range(sorted_data.shape[1]):</span>
    <span class="c1">#         up_indices = np.where(upper_cond[:, col])[0]</span>
    <span class="c1">#         if len(up_indices) &gt; 0:</span>
    <span class="c1">#             uq_outlier_index = up_indices[0]</span>
    <span class="c1">#             clipped_data[uq_outlier_index:, col] = clipped_data[uq_outlier_index-1, col]</span>

    <span class="c1">#     lower_cond = (sorted_data &lt; lq_val) &amp; (diff_sorted_data &gt; diff_array_lq_val)</span>
    <span class="c1">#     # Lower bound outlier filter</span>
    <span class="c1">#     for col in range(sorted_data.shape[1]):</span>
    <span class="c1">#         low_indices = np.where(lower_cond[:, col])[0]</span>
    <span class="c1">#         if len(low_indices) &gt; 0:</span>
    <span class="c1">#             lq_outlier_index = low_indices[-1]</span>
    <span class="c1">#             clipped_data[:lq_outlier_index+1, col] = clipped_data[lq_outlier_index+1, col]</span>

    <span class="c1">#     clipped_data = np.take_along_axis(clipped_data, np.argsort(sorted_indices, axis=0), axis=0)</span>
    <span class="c1">#     # Unshift the data</span>
    <span class="c1">#     clipped_data = 10**clipped_data + v0</span>

    <span class="c1">#     return clipped_data</span>

    <span class="c1"># def transform_array(array, negative_method):</span>
    <span class="c1">#     &quot;&quot;&quot;Negative and zero handling</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     array : numpy.ndarray</span>
    <span class="c1">#         Input data</span>
    <span class="c1">#     negative_method : str</span>
    <span class="c1">#         negative_method obtained from analyte info</span>
    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     numpy.ndarray</span>
    <span class="c1">#         Transformed data</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     match negative_method.lower():</span>
    <span class="c1">#         case &#39;gradual shift&#39;:</span>
    <span class="c1">#             if array.ndim == 2:</span>
    <span class="c1">#                 # Calculate min and max values for each column and adjust their shapes for broadcasting</span>
    <span class="c1">#                 min_val = np.nanmin(array, axis=0, keepdims=True) - 0.0001</span>
    <span class="c1">#                 max_val = np.nanmax(array, axis=0, keepdims=True)</span>

    <span class="c1">#                 # Adjust the shape of min_val and max_val for broadcasting</span>
    <span class="c1">#                 adjusted_min_val = min_val</span>
    <span class="c1">#                 adjusted_max_val = max_val</span>

    <span class="c1">#                 # Check if min values are less than or equal 0</span>
    <span class="c1">#                 min_leq_zero = adjusted_min_val &lt;= 0</span>

    <span class="c1">#                 # Perform transformation with broadcasting</span>
    <span class="c1">#                 t_array = np.where(</span>
    <span class="c1">#                     min_leq_zero,</span>
    <span class="c1">#                     (adjusted_max_val * (array - adjusted_min_val)) / (adjusted_max_val - adjusted_min_val),</span>
    <span class="c1">#                     array</span>
    <span class="c1">#                 )</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 # 1D array case, similar to original logic</span>
    <span class="c1">#                 min_val = np.nanmin(array) - 0.0001</span>
    <span class="c1">#                 max_val = np.nanmax(array)</span>
    <span class="c1">#                 if min_val &lt; 0:</span>
    <span class="c1">#                     t_array = (max_val * (array - min_val)) / (max_val - min_val)</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     t_array = np.copy(array)</span>
    <span class="c1">#             return t_array</span>

<div class="viewcode-block" id="SampleObj.apply_field_filters">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.apply_field_filters">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_field_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies filters based on field values.</span>
<span class="sd">        </span>
<span class="sd">        Field-based filters are stored in ``self.filter_df``.  This method updates ``self.filter_mask``.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># Check if rows in self.data[sample_id][&#39;filter_info&#39;] exist and filter array in current_plot_df</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;Xc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># by creating a mask based on min and max of the corresponding filter analytes</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">filter_row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">filter_row</span><span class="p">[</span><span class="s1">&#39;use&#39;</span><span class="p">]:</span>
                <span class="n">field_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map_data</span><span class="p">(</span><span class="n">filter_row</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">],</span> <span class="n">filter_row</span><span class="p">[</span><span class="s1">&#39;field_type&#39;</span><span class="p">])</span>
                
                <span class="n">operator</span> <span class="o">=</span> <span class="n">filter_row</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;and&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">filter_row</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">field_df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">field_df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;=</span> <span class="n">filter_row</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;or&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span> <span class="o">|</span> <span class="p">((</span><span class="n">filter_row</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">field_df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">field_df</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;=</span> <span class="n">filter_row</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]))</span></div>


<div class="viewcode-block" id="SampleObj.confirm_reset">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.confirm_reset">[docs]</a>
    <span class="k">def</span> <span class="nf">confirm_reset</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A simple dialog that ensures the user wishes to reset data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` indicates user clicked ``Yes``, ``False`` for ``No``</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># Create a message box</span>
        <span class="n">msgBox</span> <span class="o">=</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
            <span class="s2">&quot;Confirm Reset&quot;</span><span class="p">,</span> 
            <span class="s2">&quot;Resetting to the full map will delete all analyses, computed fields, and reset filters.&quot;</span><span class="p">,</span>
            <span class="n">QMessageBox</span><span class="o">.</span><span class="n">StandardButton</span><span class="o">.</span><span class="n">Yes</span> <span class="o">|</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">StandardButton</span><span class="o">.</span><span class="n">No</span> <span class="o">|</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">StandardButton</span><span class="o">.</span><span class="n">No</span>
        <span class="p">)</span>

        <span class="c1"># Show the message box and get the user&#39;s response</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">msgBox</span><span class="o">.</span><span class="n">exec</span><span class="p">()</span>

        <span class="c1"># Check the user&#39;s response</span>
        <span class="k">if</span> <span class="n">response</span> <span class="o">==</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">StandardButton</span><span class="o">.</span><span class="n">No</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># User chose not to proceed</span>
        <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># User chose to proceed</span></div>

    
    <span class="k">def</span> <span class="nf">sort_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="c1"># retrieve analyte_list</span>
        <span class="n">analyte_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">match_attribute</span><span class="p">(</span><span class="s1">&#39;data_type&#39;</span><span class="p">,</span><span class="s1">&#39;Analyte&#39;</span><span class="p">)</span>

        <span class="c1"># sort analyte sort based on method chosen by user</span>
        <span class="n">sorted_analyte_list</span> <span class="o">=</span> <span class="n">sort_analytes</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">analyte_list</span><span class="p">)</span>

        <span class="c1"># Ensure all analytes in self.analyte_list are actually columns in the DataFrame</span>
        <span class="c1"># Does this ever happen?</span>
        <span class="c1"># This step filters out any items in self.analyte_list that are not columns in the DataFrame</span>
        <span class="c1">#columns_to_order = [analyte for analyte in analyte_list if analyte in data.raw_data.columns]</span>

        <span class="c1"># Reorder the columns of the DataFrame based on self.analyte_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">sort_columns</span><span class="p">(</span><span class="n">sorted_analyte_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;processed_data&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">sort_columns</span><span class="p">(</span><span class="n">sorted_analyte_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">analyte_list</span><span class="p">,</span> <span class="n">sorted_analyte_list</span>


<div class="viewcode-block" id="SampleObj.auto_scale">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.auto_scale">[docs]</a>
    <span class="k">def</span> <span class="nf">auto_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sample_id</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">update</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Auto-scales pixel values in map</span>

<span class="sd">        Executes on ``MainWindow.toolButtonAutoScale`` click.</span>

<span class="sd">        Outliers can make it difficult to view the variations of values within a map.</span>
<span class="sd">        This is a larger problem for linear scales, but can happen when log-scaled. Auto-</span>
<span class="sd">        scaling the data clips the values at a lower and upper bound.  Auto-scaling may be</span>
<span class="sd">        acceptable as minerals that were not specifically calibrated can have erroneously</span>
<span class="sd">        high or low (even negative) values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        update : bool</span>
<span class="sd">            Update auto scale parameters, by default, False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
            <span class="n">analyte_1</span><span class="p">,</span> <span class="n">analyte_2</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; / &#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">analyte_1</span> <span class="o">=</span> <span class="n">field</span>
            <span class="n">analyte_2</span> <span class="o">=</span> <span class="kc">None</span>



        <span class="n">lb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_min_quantile</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_max_quantile</span>
        <span class="n">d_lb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_min_diff_quantile</span>
        <span class="n">d_ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_max_diff_quantile</span>
        <span class="n">auto_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_scale_value</span>

        <span class="k">if</span> <span class="n">auto_scale</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">update</span><span class="p">:</span>
            <span class="c1">#reset to default auto scale values</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="mf">0.05</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="mf">99.5</span>
            <span class="n">d_lb</span> <span class="o">=</span> <span class="mi">99</span>
            <span class="n">d_ub</span> <span class="o">=</span> <span class="mi">99</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">data_min_quantile</span> <span class="o">=</span> <span class="n">lb</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_max_quantile</span> <span class="o">=</span> <span class="n">ub</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_min_diff_quantile</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">d_lb</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_max_diff_quantile</span> <span class="o">=</span> <span class="n">d_ub</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">auto_scale_value</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">auto_scale</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">update</span><span class="p">:</span>
            <span class="c1"># show unbounded plot when auto scale switched off</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_min_quantile</span> <span class="o">=</span> <span class="n">lb</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_max_quantile</span> <span class="o">=</span> <span class="n">ub</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_min_diff_quantile</span><span class="o">.</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">auto_scale_value</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># if update is true</span>
        <span class="k">if</span> <span class="n">analyte_1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">analyte_2</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_outlier_to_all</span><span class="p">):</span>
                <span class="c1"># Apply to all analytes in sample</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">columns</span>

                <span class="c1"># clear existing plot info from tree to ensure saved plots using most recent data</span>
                <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Analyte&#39;</span><span class="p">,</span> <span class="s1">&#39;Analyte (normalized)&#39;</span><span class="p">,</span> <span class="s1">&#39;Ratio&#39;</span><span class="p">,</span> <span class="s1">&#39;Ratio (normalized)&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plot_tree</span><span class="o">.</span><span class="n">clear_tree_data</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">analyte_1</span>

            <span class="c1"># update column attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s1">&#39;auto_scale&#39;</span><span class="p">,</span> <span class="n">auto_scale</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s1">&#39;upper_bound&#39;</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s1">&#39;lower_bound&#39;</span><span class="p">,</span> <span class="n">lb</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s1">&#39;diff_upper_bound&#39;</span><span class="p">,</span> <span class="n">d_ub</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s1">&#39;diff_lower_bound&#39;</span><span class="p">,</span> <span class="n">d_lb</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s1">&#39;negative_method&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comboBoxNegativeMethod</span><span class="o">.</span><span class="n">currentText</span><span class="p">())</span>

            <span class="c1"># update data with new auto-scale/negative handling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="p">(</span><span class="n">sample_id</span><span class="p">)</span>
            

        <span class="c1"># else:</span>
        <span class="c1">#     if self.apply_outlier_to_all:</span>
        <span class="c1">#         # Apply to all ratios in sample</span>
        <span class="c1">#         self.processed_data[&#39;ratio_info&#39;][&#39;auto_scale&#39;] = auto_scale</span>
        <span class="c1">#         self.processed_data[&#39;ratio_info&#39;][&#39;upper_bound&#39;]= ub</span>
        <span class="c1">#         self.processed_data[&#39;ratio_info&#39;][&#39;lower_bound&#39;] = lb</span>
        <span class="c1">#         self.processed_data[&#39;ratio_info&#39;][&#39;d_l_bound&#39;] = d_lb</span>
        <span class="c1">#         self.processed_data[&#39;ratio_info&#39;][&#39;d_u_bound&#39;] = d_ub</span>
        <span class="c1">#         self.prep_data(sample_id)</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         self.processed_data[&#39;ratio_info&#39;].loc[ (self.processed_data[&#39;ratio_info&#39;][&#39;Analyte_1&#39;]==analyte_1)</span>
        <span class="c1">#                                     &amp; (self.processed_data[&#39;ratio_info&#39;][&#39;Analyte_2&#39;]==analyte_2),&#39;auto_scale&#39;]  = auto_scale</span>
        <span class="c1">#         self.processed_data[&#39;ratio_info&#39;].loc[ (self.processed_data[&#39;ratio_info&#39;][&#39;Analyte_1&#39;]==analyte_1)</span>
        <span class="c1">#                                     &amp; (self.processed_data[&#39;ratio_info&#39;][&#39;Analyte_2&#39;]==analyte_2),</span>
        <span class="c1">#                                     [&#39;upper_bound&#39;,&#39;lower_bound&#39;,&#39;d_l_bound&#39;, &#39;d_u_bound&#39;]] = [ub,lb,d_lb, d_ub]</span>
        <span class="c1">#         self.prep_data(sample_id, analyte_1,analyte_2)</span>
        <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># User chose to proceed</span></div>


<div class="viewcode-block" id="SampleObj.sort_data">
<a class="viewcode-back" href="../../generated/common.DataHandling.html#common.DataHandling.SampleObj.sort_data">[docs]</a>
    <span class="k">def</span> <span class="nf">sort_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="c1"># retrieve analyte_list</span>
        <span class="n">analyte_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_data</span><span class="o">.</span><span class="n">match_attribute</span><span class="p">(</span><span class="s1">&#39;data_type&#39;</span><span class="p">,</span><span class="s1">&#39;Analyte&#39;</span><span class="p">)</span>
        <span class="n">sorted_analyte_list</span> <span class="o">=</span> <span class="n">sort_analytes</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">analyte_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">analyte_list</span><span class="p">,</span> <span class="n">sorted_analyte_list</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2025, Shavin Kaluthantri, Derrick Hasterok, and Maggie Li.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>