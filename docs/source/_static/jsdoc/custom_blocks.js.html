<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: custom_blocks.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: custom_blocks.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
.. module:: custom_blocks
   :synopsis: Blockly blocks for LaserMapExplorer workflow UI.

Overview
========
This module defines all custom Blockly blocks used by the LaserMapExplorer UI.
Blocks are grouped to mirror the toolbox categories defined in ``index.html``:

- **Global Settings**
- **File I/O**
- **Samples and fields**
- **Analysis**
- **Plot**
- **Multidimensional**
- **Style**

Each block docstring below includes:

- **Block name** and **category**
- **Purpose/behavior**
- **Fields** (names, types, defaults)
- **Connections** (previous/next/output types)
- **Side effects / bridge calls** (when relevant)

These comments use reStructuredText so they can be copied into Sphinx docs,
or parsed by a simple comment extractor to generate ``.rst`` content.
*/

import * as Blockly from 'blockly/core';
import * as BlockDynamicConnection from '@blockly/block-dynamic-connection';
import {registerFieldColour, FieldColour} from '@blockly/field-colour';
registerFieldColour();
import { sample_ids,fieldTypeList, baseDir } from './globals';
import {decorateBlock, updateFieldDropdown,updateFieldTypeDropdown,addDefaultStylingBlocks,updateStylingChain, updateHistogramOptions, isBlockInChain, listSelectorChanged, updateNDimListDropdown, updateSavePlotPreview,setDefaultSaveDir } from './helper_functions'
window.Blockly = Blockly.Blocks

/*
Summary of Naming Conventions:
Field Names: Camel case (plotType).
Variable Names (js): Camel case (plotType).
Block Type Names: Snake case (set_plot_type).
Block Input Names: Snake case (set_plot_type).
*/


//// Global Settings //// 

// ---- Display figures (x : top &amp; bottom) ----
/**
.. block:: display_figure
   :category: Global Settings
   :color: 360

Toggle the figure display policy for plots.

**Fields**
- **SHOW** (Checkbox, default TRUE): When TRUE, plots open in a modal dialog
  (Continue/Stop/Skip). When FALSE, plots are embedded and workflow proceeds.

**Connections**
- Previous: Statement
- Next: Statement
*/
const display_figure = {
  init: function () {
    this.appendDummyInput('HEADER')
      .appendField('Display figures')
      .appendField(new Blockly.FieldCheckbox('TRUE'), 'SHOW');

    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(285);
    this.setTooltip('When enabled, plots open in a modal dialog with Continue/Stop/Skip controls.');
    this.setHelpUrl('');
  }
};
Blockly.common.defineBlocks({ display_figure });


//// File I/O //// 

/**
.. block:: load_directory
   :category: File I/O
   :color: 60

Load all files from a directory.

**Fields**
- **DIR** (TextInput on value input): Directory path string.

**Connections**
- Output: none
- Next: Statement
*/
const load_directory = {
    init: function() {
        this.appendValueInput('DIR')
            .setCheck('String')
            .appendField('load files from directory')
            .appendField(new Blockly.FieldTextInput('directory path'), 'DIR');
        this.setNextStatement(true, null);
        this.setTooltip('Loads files from a directory');
        this.setHelpUrl('');
        this.setColour(60);
    }
};
Blockly.Blocks['load_directory'] = load_directory;

/**
.. block:: load_sample
   :category: File I/O
   :color: 60

Load a single sample from a directory or file path.

**Fields**
- **DIR** (TextInput on value input): File path string.

**Connections**
- Previous: Statement
- Next: Statement
*/
const load_sample = {
    init: function() {
        this.appendValueInput('DIR')
            .setCheck('String')
            .appendField('load sample from directory')
            .appendField(new Blockly.FieldTextInput('file path'), 'DIR');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('Loads files from a directory');
        this.setHelpUrl('');
        this.setColour(60);
    }
};
Blockly.Blocks['load_sample'] = load_sample;

// Block: Save Plot
/**
.. block:: save_plot
   :category: File I/O
   :color: 230

Save the current canvas figure and/or associated data to disk.  
Supports changing the save directory, setting a file basename, and
choosing both figure and data output formats. Live previews of the
resulting save paths are displayed inside the block.

**Fields**
- **DIRECTORY** (Text): Path to the save directory.
- **CHANGE_DIR** (Dropdown): Action to change directory.
- **BASENAME** (Text): Base filename (without extension).
- **SAVE_FIGURE** (Checkbox): Whether to save a figure.
- **FIG_TYPE** (Dropdown): File type for figure (png, jpg, svg, pdf).
- **SAVE_DATA** (Checkbox): Whether to save data.
- **DATA_TYPE** (Dropdown): File type for data (csv, xlsx, parquet).
- **FIG_PREVIEW** (Label): Preview of figure save path.
- **DATA_PREVIEW** (Label): Preview of data save path.

**Inputs**
- None

**Connections**
- Previous: Statement
- Next: Statement
*/
Blockly.Blocks['save_plot'] = {
  init: function() {
    this.appendDummyInput().appendField("save plot");

     // Minimal change-dir dropdown used as a button
    const changeDir = new Blockly.FieldDropdown([["current path","IDLE"], ["change…","CHANGE"]], (v) => {
      if (v !== "CHANGE") return v;           // only act on explicit select
      const f = this.getField('DIRECTORY');
      const cur = (f ? f.getValue() : "") || "";
      const r = window.blocklyBridge.selectDirectory(cur);
      (r &amp;&amp; typeof r.then === 'function') ? r.then(p => { if (p) f.setValue(p); updateSavePlotPreview(this); this.getField('CHANGE_DIR')?.setValue('IDLE'); })
                                    : (r &amp;&amp; f.setValue(r));
      this.getField('CHANGE_DIR')?.setValue('IDLE');  // reset to neutral
      updateSavePlotPreview(this);
      return 'IDLE';
    });
    
    this.appendDummyInput()
        .appendField("directory")
        .appendField(new Blockly.FieldTextInput("path/to/folder"), "DIRECTORY")
        .appendField(changeDir, "CHANGE_DIR");
    changeDir.setValue('IDLE');  // neutral default

    this.appendDummyInput()
        .appendField("basename")
        .appendField(new Blockly.FieldTextInput(""), "BASENAME");

    this.appendDummyInput()
        .appendField(new Blockly.FieldCheckbox("TRUE"), "SAVE_FIGURE")
        .appendField("save figure as")
        .appendField(new Blockly.FieldDropdown([
          ["png","png"], ["jpg","jpg"], ["svg","svg"], ["pdf","pdf"]
        ]), "FIG_TYPE");

    this.appendDummyInput()
        .appendField(new Blockly.FieldCheckbox("TRUE"), "SAVE_DATA")
        .appendField("save data as")
        .appendField(new Blockly.FieldDropdown([
          ["csv","csv"], ["xlsx","xlsx"], ["parquet","parquet"]
        ]), "DATA_TYPE");

    // Live preview labels (use Serializable so we can update text)
    this.appendDummyInput()
        .appendField("figure path:")
        .appendField(new Blockly.FieldLabelSerializable("—"), "FIG_PREVIEW");

    this.appendDummyInput()
        .appendField("data path:")
        .appendField(new Blockly.FieldLabelSerializable("—"), "DATA_PREVIEW");

    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
    this.setTooltip("Save current canvas figure and/or data to disk.");
    this.setHelpUrl("");

    // Fetch default dir once the block is created
    setDefaultSaveDir(this);

    // Live updates when any relevant field changes
    const block = this;
    this.setOnChange(function(e) {
      // Only recompute on field changes to our block
      if (!e || e.blockId !== block.id) return;
      updateSavePlotPreview(block);
    });
  }
};



//// Samples and Fields /////
// Block: Select Sample ID
/**
.. block:: select_samples
   :category: File I/O
   :color: 160

Select a single sample ID from the currently available list.  
Sample IDs are dynamically populated from the application state.

**Fields**
- **SAMPLE_IDS** (Dropdown): Dropdown of available sample IDs.

**Inputs**
- None

**Connections**
- Previous: Statement
- Next: Statement
*/
const select_samples = {
    init: function() {
        this.appendDummyInput().appendField('Select sample ID').appendField(new Blockly.FieldDropdown(this.getOptions), 'SAMPLE_IDS');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip('Selects a sample ID');
        this.setHelpUrl('');
    },
    getOptions: function() {
        if (!sample_ids.length) {
            return [['No sample IDs available', 'NONE']];
        }
        return sample_ids.map(id => [id, id]);
    },
};
Blockly.Blocks['select_samples'] = select_samples;

 // Block: loop over Sample IDs
/**
.. block:: loop_over_samples
   :category: File I/O
   :color: 180

Iterate over the current set of sample IDs.

**Fields**
- **SAMPLE_IDS** (Variable dropdown): Variable referencing an array of sample IDs.

**Inputs**
- **DO** (Statement): Body to execute per sample.

**Connections**
- Previous: Statement
- Next: Statement
*/
 const loop_over_samples = {
    init: function() {
        this.appendDummyInput('NAME')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Loop over samples');
        this.appendDummyInput()
            .appendField("for each sample ID in")
            .appendField(new Blockly.FieldVariable("sample_ids"), "SAMPLE_IDS");

        this.appendStatementInput("DO")
            .appendField("do");

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(180);
        this.setTooltip('Loop over each sample in the provided directory');
        this.setHelpUrl('');
    }
};
Blockly.common.defineBlocks({ loop_over_samples: loop_over_samples });

// Block: loop over fields
/**
.. block:: loop_over_fields
   :category: File I/O
   :color: 60

Iterate over fields for the selected field type.

**Fields**
- **fieldType** (Dropdown): Field type selector (populated from ``fieldTypeList``).

**Inputs**
- **DO** (Statement): Body to execute per field.

**Connections**
- Previous: Statement
- Next: Statement
*/

const loop_over_fields = {
    init: function() {
        this.appendDummyInput('NAME')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Loop over fields');
        this.appendDummyInput()
            .appendField("for each field in")
            .appendField('field type')
            .appendField(new Blockly.FieldDropdown(function() {
                return fieldTypeList;
            }), 'fieldType');
        this.appendStatementInput("DO")
            .appendField("do");

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(60);
        this.setTooltip('Loop over each field in the selected field type');
        this.setHelpUrl('');
    }
};


Blockly.common.defineBlocks({ loop_over_fields: loop_over_fields });

/**
.. block:: select_analytes
   :category: Samples and fields
   :color: 180

Choose analytes/ratios via dialog, current selection, or saved lists.

**Fields**
- **analyteSelectorDropdown** (Dropdown): 'Analyte selector' | 'Current selection' | 'Saved lists'.
- **analyteSavedListsDropdown** (Dropdown, hidden by default): Populated on demand.

**Connections**
- Previous: Statement
- Next: Statement

Side effects
------------
Delegates to ``listSelectorChanged(.., 'analyte')`` which calls into the bridge
to open dialogs and/or update saved lists.
*/
Blockly.common.defineBlocks({ 
    select_analytes: {
        init: function() {
            this.appendDummyInput('NAME')
                .setAlign(Blockly.inputs.Align.CENTRE)
                .appendField('Select analytes/ratios');

            // Initialize the analyte selector dropdown
            this.appendDummyInput('SELECTOR')
                .appendField(new Blockly.FieldLabelSerializable('Analyte/Ratio list from'), 'NAME')
                .appendField(new Blockly.FieldDropdown(
                    [
                        ['Analyte selector', 'Analyte selector'],
                        ['Current selection', 'Current selection'],
                        ['Saved lists', 'Saved lists']
                    ]
                ), 'analyteSelectorDropdown');

            // Add the analyte saved lists dropdown, initially hidden
            this.appendDummyInput('SAVED_LISTS')
                .appendField('Saved list')
                .appendField(new Blockly.FieldDropdown([['None', 'None']]), 'analyteSavedListsDropdown')
                .setVisible(false);

            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setTooltip('');
            this.setHelpUrl('');
            this.setColour(180);

            // Use the common validator that calls selectorChanged(...)
            const dropdown = this.getField('analyteSelectorDropdown');
            dropdown.setValidator((newValue) => {
                return listSelectorChanged(newValue, this, 'analyte');
            });
        }
    }
});

/**
.. block:: select_field_from_type
   :category: Samples and fields
   :color: 180

Select one (or all/none) fields from a specific field type.

**Fields**
- **fieldType** (Dropdown): Populated dynamically via ``updateFieldTypeDropdown``.
- **field** (Dropdown): Populated dynamically via ``updateFieldDropdown``; supports
  special values **__ALL__** and **__NONE__**.

**Connections**
- Previous: ``custom_field``
- Next: ``custom_field``

Notes
-----
Intended for chaining into custom field selection (e.g., clustering options).
*/
Blockly.common.defineBlocks({
  select_field_from_type: {
    init: function () {
      this.appendDummyInput('NAME')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Select fields from field type');

      // Field type dropdown
      this.appendDummyInput('FIELD_TYPE')
        .appendField('Field type')
        .appendField(
          new Blockly.FieldDropdown([['Select...', '']]),
          'fieldType'
        );

      // Field dropdown (with All/None defaults)
      this.appendDummyInput('FIELD')
        .appendField('Field')
        .appendField(
          new Blockly.FieldDropdown([
            ['All', '__ALL__'],
            ['None', '__NONE__'],
            ['Select...', '']
          ]),
          'field'
        );

      this.setPreviousStatement(true, 'custom_field');
      this.setNextStatement(true, 'custom_field');
      this.setColour(180);
      this.setTooltip('Select a field type and specific field(s).');
      this.setHelpUrl('');

      if (!this.isInFlyout) {
        // Dynamically update FieldType list

        updateFieldTypeDropdown(this, 'field map', 'c', 'fieldType', 'field');

        const fieldTypeDropdown = this.getField('fieldType');
        fieldTypeDropdown.setValidator((newValue) => {
            this.argDict = this.argDict || {};
            this.argDict['c_field_type'] = newValue;
            updateFieldDropdown(this, newValue, 'field');
            return newValue;
        });
       const fieldDropdown = this.getField('field');
        fieldDropdown.setValidator((newValue) => {
            this.argDict = this.argDict || {};
            this.argDict['c_field'] = newValue;
            return newValue;
        }); 

      }
    }
  }
});

/**
.. block:: select_fields_list
   :category: Samples and fields
   :color: 180

Use field selector dialog, current selection, or saved lists to define a set of fields.

**Fields**
- **fieldSelectorDropdown** (Dropdown): 'Field selector' | 'Current selection' | 'Saved lists'.
- **fieldSavedListsDropdown** (Dropdown, hidden by default): List names from disk.

**Connections**
- Previous: ``custom_field``
- Next: ``custom_field``

Side effects
------------
Delegates to ``listSelectorChanged(.., 'field')`` and related bridge helpers.
*/
Blockly.common.defineBlocks({
    select_fields_list: {
        init: function() {
            this.appendDummyInput('NAME')
                .setAlign(Blockly.inputs.Align.CENTRE)
                .appendField('Select fields from');

            // Initialize the field selector dropdown
            this.appendDummyInput('SELECTOR')
                .appendField(new Blockly.FieldLabelSerializable('Field list from'), 'NAME')
                .appendField(new Blockly.FieldDropdown(
                    [
                        ['Field selector', 'Field selector'],
                        ['Current selection', 'Current selection'],
                        ['Saved lists', 'Saved lists']
                    ]
                ), 'fieldSelectorDropdown');

            // Add the field saved lists dropdown, initially hidden
            this.appendDummyInput('SAVED_LISTS')
                .appendField('Saved list')
                .appendField(new Blockly.FieldDropdown([['None', 'None']]), 'fieldSavedListsDropdown')
                .setVisible(false);

            // Restrict connections so this block can only connect to custom_field chains
            this.setPreviousStatement(true, 'custom_field');
            this.setNextStatement(true, 'custom_field');
            this.setTooltip('Select a set of fields from different sources.');
            this.setHelpUrl('');
            this.setColour(180);

            // Use the common validator that calls selectorChanged(...)
            const dropdown = this.getField('fieldSelectorDropdown');
            dropdown.setValidator((newValue) => {
                return listSelectorChanged(newValue, this, 'field');
            });
        }
    }
});

/**
.. block:: export_table
   :category: File I/O
   :color: 60

Export a table of selected fields.

**Inputs**
- **fields** (Statement): Chain limited to ``select_fields_list`` and/or
  ``select_field_from_type``.

**Connections**
- Output: ``export_table`` (for use by analysis/plot generators)

Notes
-----
This block only represents the *selection*; actual export is performed
in the corresponding Python generator function.
*/

Blockly.common.defineBlocks({
  export_table: {
    init: function() {
      this.appendDummyInput()
            .setAlign(Blockly.inputs.Align.CENTRE)
            .appendField('Export Table');

      // Statement input that can hold select_fields_list or select_field_from_type
      this.appendStatementInput('fields')
          .setCheck(['select_fields_list', 'select_field_from_type'])
          .appendField('Fields to export');

      // So it can be attached to the "exportTable" Value Input in correlation_analysis:
      this.setOutput(true, 'export_table');

      this.setColour(60);
      this.setTooltip('Exports selected fields as a table.');
      this.setHelpUrl('');
    }
  }
});



// Define the select_ref_val block
/**
.. block:: select_ref_val
   :category: Samples and fields
   :color: 180

Pick a reference composition/value list for normalization or TEC plots.

**Fields**
- **refValueDropdown** (Dropdown): Populated dynamically via bridge (e.g., reference sets).

**Connections**
- Previous: Statement
- Next: Statement
*/

const select_ref_val = {
  init: function () {
    const block = this;

    block.appendDummyInput('NAME')
      .setAlign(Blockly.inputs.Align.CENTRE)
      .appendField('Select Reference value');

    block.appendDummyInput('refValue')
      .appendField('Ref. value')
      .appendField(new Blockly.FieldDropdown([
        ['bulk silicate Earth [MS95] McD', 'bulk_silicate_earth'],
        ['option 2', 'option_2']
      ]), 'refValueDropdown');

    block.setPreviousStatement(true, null);
    block.setNextStatement(true, null);
    block.setColour(180);

    if (!block.workspace || block.workspace.isFlyout) return;

    // Update options from Python
    window.blocklyBridge?.getRefValueList?.().then((response) => {
      const options = response.map(opt => [opt, opt]);
      const dropdown = block.getField('refValueDropdown');
      if (dropdown &amp;&amp; options.length) {
        dropdown.menuGenerator_ = options; // update
        dropdown.setValue(options[0][1]);  // default
        dropdown.forceRerender?.();        // refresh
      }
    }).catch(err => console.error('Error fetching reference list:', err));
  }
};

Blockly.common.defineBlocks({ select_ref_val });


// Define the change_pixel_dimensions block
/**
.. block:: change_pixel_dimensions
   :category: Samples and fields
   :color: 180

Set spatial pixel dimensions (dx, dy) from current dataset defaults.

**Fields**
- **dx** (Number)
- **dy** (Number)

**Connections**
- Previous: Statement
- Next: Statement

Side effects
------------
Calls ``getCurrentDimensions()`` via bridge, rounds to 4 decimals, writes fields.
*/
const change_pixel_dimensions= {
    init: function() {
        this.appendDummyInput()
            .appendField("Set Dimensions");
        this.appendDummyInput()
            .appendField("dx")
            .appendField(new Blockly.FieldNumber(0), "dx");
        this.appendDummyInput()
            .appendField("dy")
            .appendField(new Blockly.FieldNumber(0), "dy");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(180);
        this.setTooltip("Set the dx and dy dimensions");
        this.setHelpUrl("");

        // Update the default values of dx and dy
        this.updateDimensions();
    },

    updateDimensions: function() {
        var block = this;
        // Call the Python function get_current_dimensions through the WebChannel
        window.blocklyBridge.getCurrentDimensions().then(function(dimensions) {
            var dx = dimensions[0];
            var dy = dimensions[1];
            // Round dx and dy to 4 decimal places
            dx = Number(dx.toFixed(4));
            dy = Number(dy.toFixed(4));
            // Set the field values
            block.setFieldValue(dx, 'dx');
            block.setFieldValue(dy, 'dy');
        }).catch(function(error) {
            console.error('Error fetching dimensions:', error);
        });
    }
};

Blockly.common.defineBlocks({change_pixel_dimensions: change_pixel_dimensions});

/**
.. block:: swap_pixel_dimensions
   :category: Samples and fields
   :color: 180

Swap the stored pixel dimensions dx ↔ dy.

**Connections**
- Previous: Statement
- Next: Statement
*/
const swap_pixel_dimensions= {
    init: function() {
      this.appendDummyInput()
          .appendField("Swap Dimensions dx ↔ dy");
      this.setPreviousStatement(true, null);
      this.setNextStatement(true, null);
      this.setColour(180);
      this.setTooltip("Swap the values of dx and dy");
      this.setHelpUrl("");
    }
  };

Blockly.common.defineBlocks({swap_pixel_dimensions: swap_pixel_dimensions});

/**
.. block:: swap_x_y
   :category: Samples and fields
   :color: 180

Swap the coordinate axes x ↔ y.

**Connections**
- Previous: Statement
- Next: Statement
*/
const swap_x_y= {
    init: function() {
      this.appendDummyInput()
          .appendField("Swap x ↔ y");
      this.setPreviousStatement(true, null);
      this.setNextStatement(true, null);
      this.setColour(180);
      this.setTooltip("Swap the values of coordinate axes");
      this.setHelpUrl("");
    }
  };

Blockly.common.defineBlocks({swap_x_y: swap_x_y});

/**
.. block:: select_outlier_method
   :category: Samples and fields
   :color: 180

Choose an outlier handling method and optional bounds.

**Fields**
- **outlierMethodDropdown** (Dropdown): presets (none, quantile, Chauvenet, etc.).
- **QB** (Dummy, hidden by default): Quantile lower/upper bounds.
- **DB** (Dummy, hidden by default): Difference bounds.

**Connections**
- Previous: Statement
- Next: Statement

Behavior
--------
Field visibility auto-toggles based on the chosen method.
*/
const select_outlier_method = {
    init: function() {
        this.appendDummyInput('NAME')
            .setAlign(Blockly.inputs.Align.CENTRE)
            .appendField('Select outlier method');

        // Initialize the analyte selector dropdown
        this.appendDummyInput('SELECTOR')
            .appendField(new Blockly.FieldLabelSerializable('Outlier method'), 'NAME')
            .appendField(new Blockly.FieldDropdown(
                [['none', 'none'],
                 ['quantile criteria', 'quantile criteria'],
                 ['quantile and distance criteria', 'quantile and distance criteria'],
                 ['Chauvenet criterion', 'chauvenet criterion'],
                 ['log(n>x) inflection', 'log(n>x) inflection']]
            ), 'outlierMethodDropdown');

        // Add the quantile bounds, initially hidden
        this.appendDummyInput('QB')
            .appendField("Quantile bounds")
            .appendField(new Blockly.FieldNumber(0.05), "lB")
            .appendField(new Blockly.FieldNumber(99.5), "uB")
            .setVisible(false);
        // Add the difference bounds, initially hidden
        this.appendDummyInput('DB')
            .appendField("Difference bound")
            .appendField(new Blockly.FieldNumber(99), "dLB")
            .appendField(new Blockly.FieldNumber(99), "dUB")
            .setVisible(false);

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('');
        this.setHelpUrl('');
        this.setColour(180);

        // Handle the selection change in analyteSelectorDropdown
        const dropdown = this.getField('outlierMethodDropdown');
        dropdown.setValidator(this.outlierMethodChanged.bind(this));
        // Set initial visibility based on the default selection
        const initialValue = this.getFieldValue('outlierMethodDropdown');
        this.outlierMethodChanged(initialValue);
    },

    outlierMethodChanged: function(newValue) {
        const qbInput = this.getInput('QB');
        const dbInput = this.getInput('DB');

        if (newValue === 'quantile criteria') {
            qbInput.setVisible(true);
            dbInput.setVisible(false);
        } else if (newValue === 'quantile and distance criteria') {
            qbInput.setVisible(true);
            dbInput.setVisible(true);
        } else {
            qbInput.setVisible(false);
            dbInput.setVisible(false);
        }

        // Refresh the block to reflect the visibility change
        this.render();

        return newValue;
    }
};

Blockly.common.defineBlocks({ select_outlier_method: select_outlier_method });

/**
.. block:: neg_handling_method
   :category: Samples and fields
   :color: 180

Select strategy for negative values.

**Fields**
- **negMethodDropdown** (Dropdown): 'ignore negatives' | 'minimum positive' | etc.

**Connections**
- Previous: Statement
- Next: Statement
*/
const neg_handling_method = {
    init: function() {
        this.appendDummyInput('NAME')
            .setAlign(Blockly.inputs.Align.CENTRE)
            .appendField('Select negative handling method');

        // Initialize the analyte selector dropdown
        this.appendDummyInput('SELECTOR')
            .appendField(new Blockly.FieldLabelSerializable('Neg. handling method'), 'NAME')
            .appendField(new Blockly.FieldDropdown(
                [['ignore negatives', 'ignore negatives'],
                 ['minimum positive', 'minimum positive'],
                 ['gradual shift', 'gradual shift'],
                 ['Yeo-Johnson transform', 'Yeo-Johnson transform']]
            ), 'negMethodDropdown');

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('');
        this.setHelpUrl('');
        this.setColour(180);
    }
};
Blockly.common.defineBlocks({ neg_handling_method: neg_handling_method });



// Define the field_select block
const field_select = {
    init: function() {
        // Add a header with centered alignment
        this.appendDummyInput('header')
            .setAlign(Blockly.inputs.Align.CENTRE)
            .appendField('Select fields');

        // Create the 'Field type' dropdown with options
        this.appendDummyInput('NAME')
            .appendField('Field type')
            .appendField(new Blockly.FieldDropdown(
                [
                    ['Analyte', 'Analyte'],
                    ['Analyte (Normalised)', 'Analyte (Normalised)'],
                    ['PCA Score', 'PCA Score'],
                    ['Cluster', 'Cluster']
                ],
                this.updateFieldDropdown.bind(this)  // Bind the update function
            ), 'fieldType');

        // Create the 'field' dropdown, initially empty
        this.appendDummyInput('FIELD')
            .appendField('Field')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'field');

        this.setInputsInline(false);
        this.setTooltip('Select fields for analysis');
        this.setHelpUrl('');
        this.setColour(160);  // Adjust color as needed
        this.setOutput(true, null); 

        // Initialize the 'field' dropdown options based on the default 'fieldType' value
        const initialFieldType = this.getFieldValue('fieldType');
        this.updateFieldDropdown(initialFieldType);
    },

    updateFieldDropdown: function(newValue) {
        const fieldTypeValue = newValue || this.getFieldValue('fieldType');

        // Call the Python function getFieldList through the WebChannel, handle as a promise
        window.blocklyBridge.getFieldList(fieldTypeValue).then((response) => {
            // Map the response to the required format for Blockly dropdowns
            const options = response.map(option => [option, option]);

            // Add 'none' and 'all' options at the beginning
            options.unshift(['all', 'all']);
            options.unshift(['none', 'none']);

            const dropdown = this.getField('field');

            // Update the dropdown options
            dropdown.menuGenerator_ = options;

            // Set the default value to 'Select...' or to the first option if options are available
            if (options.length > 0) {
                dropdown.setValue(options[0][1]);
            } else {
                dropdown.setValue('');
            }

            dropdown.forceRerender();  // Refresh dropdown to display updated options
        }).catch(error => {
            console.error('Error fetching field list:', error);
        });
    }
};

// Register the block with Blockly
Blockly.common.defineBlocks({ field_select: field_select });

/**
.. block:: plot_map
   :category: Plot
   :color: 285

Render a 2D field map with optional polygons and styling chain.

**Fields**
- **fieldType** (Dropdown, dynamic)
- **field** (Dropdown, dynamic)

**Inputs**
- **styling** (Statement: 'styling' chain)
- **Polygons** (Statement: 'Polygons' chain)

**Connections**
- Previous: Statement
- Next: ``PLOT_OUTPUT``

Side effects
------------
Synchronizes style args via ``updateStylingChain`` when dropdowns or styling chain change.
*/
const plot_map = {
    init: function () {
        this.appendDummyInput('header')
            .appendField('Plot Map')
            .setAlign(Blockly.inputs.Align.CENTRE);

        
        this.appendDummyInput('NAME')
            .appendField('Field type')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'fieldType');

        this.appendDummyInput('FIELD')
            .appendField('Field')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'field');
        // Add dynamic statement input for styling
        const stylingInput = this.appendStatementInput('styling')
            .setCheck('styling')
            .appendField('Styling');
        
        // Add dynamic statement input for styling
        this.appendStatementInput('Polygons')
            .setCheck('Polygons')
            .appendField('Polygons');

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, 'PLOT_OUTPUT');
        this.setTooltip('Configure and render a plot with specified type and settings.');
        this.setHelpUrl('');
        this.setColour(285);

        this.plotType = 'field map'

        this.plotName =  this.getFieldValue('field')|| 'plot';
        // Add default blocks to Styling input only in the toolbox
        if (!this.isInFlyout) {
            const defaultBlocks = ['x_axis', 'y_axis', 'font', 'colormap'];
            addDefaultStylingBlocks(this,this.workspace, defaultBlocks);
            //  Attach validators to fieldType and field
            // Default: axis = 'c' for 'C' axis; adjust as needed
            const axis = 'c';
            updateFieldTypeDropdown(this, this.plotType, axis, 'fieldType', 'field');

            // Attach validators to dropdowns
            const fieldTypeDropdown = this.getField('fieldType');
            fieldTypeDropdown.setValidator((newValue) => {
                this.argDict = this.argDict || {};
                this.argDict['c_field_type'] = newValue;
                updateFieldDropdown(this, newValue, 'field');  // When fieldType changes, update fields
                return newValue;
            });
            const fieldDropdown = this.getField('field');
            fieldDropdown.setValidator((newValue) => {
                this.argDict = this.argDict || {};
                this.argDict['c_field'] = newValue;
                this.argDict['plot_type'] = this.plotType;
                updateStylingChain(this, this.argDict);
                return newValue;
            });
        }
        this.setOnChange(function(event) {
            // 1) If no workspace or block is in the flyout, do nothing
            if (!this.workspace || this.isInFlyout) return;
          
            // 2) Only care about create/move/delete events
            if (
              event.type === Blockly.Events.BLOCK_CREATE ||
              event.type === Blockly.Events.BLOCK_MOVE ||
              event.type === Blockly.Events.BLOCK_DELETE
            ) {
              // 3) Check if the changed block is in the "styling" chain
              //    For instance, we can do:
              if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId)) {
                // 4) Call updateStylingChain(...)
                updateStylingChain(this);
              }
            }
        })
    }
};
Blockly.common.defineBlocks({ plot_map: plot_map });

/**
.. block:: plot_correlation
   :category: Plot
   :color: 285

Compute and plot correlation between two variables.

**Fields**
- **method** (Dropdown: Pearson|Spearman|Kendall)
- **rSquared** (Checkbox): Display R² label.

**Inputs**
- **exportTable** (Value: ``export_table``) Optional table export selection.

**Connections**
- Previous: Statement
- Next: Statement
*/
const plot_correlation = {
    init: function() {
        this.appendDummyInput('VARIABLE1')
            .appendField('Correlation');
        this.appendDummyInput()
            .appendField('Method')
            .appendField(new Blockly.FieldDropdown([
                ['Pearson', 'Pearson'],
                ['Spearman', 'Spearman'],
                ['Kendall', 'Kendall']
            ]), 'method');
        this.appendDummyInput()
            .appendField('R^2')
            .appendField(new Blockly.FieldCheckbox('TRUE'), 'rSquared');
        this.appendValueInput('exportTable')
            .setCheck('export_table')
            .appendField('Export')
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(285);
        this.setTooltip('Performs correlation analysis between two variables.');
        this.setHelpUrl('');
    }
};
Blockly.Blocks['plot_correlation'] = plot_correlation;

/**
.. block:: plot_histogram
   :category: Plot
   :color: 285

Histogram (PDF/CDF/log scaling) for a field.

**Fields**
- **histType** (Dropdown: PDF|CDF|log-scaling)
- **fieldType**, **field** (Dropdowns, dynamic)

**Inputs**
- **histogramOptions** (Statement)
- **styling** (Statement: 'styling' chain)

**Connections**
- Previous: Statement
- Next: Statement
*/
const plot_histogram = {
    init: function () {
        this.appendDummyInput('header')
            .appendField('Plot Histogram')
            .setAlign(Blockly.inputs.Align.CENTRE);

        // Type dropdown
        this.appendDummyInput('TYPE')
            .appendField('Type')
            .appendField(new Blockly.FieldDropdown([
                ['PDF', 'PDF'],
                ['CDF', 'CDF'],
                ['log-scaling', 'log-scaling'],
            ]), 'histType');

        // Field type dropdown
        this.appendDummyInput('FIELD_TYPE')
            .appendField('Field type')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'fieldType');

        // Field dropdown
        this.appendDummyInput('FIELD')
            .appendField('Field')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'field');

        // Add statement input for histogram options
        this.appendStatementInput('histogramOptions')
            .setCheck('histogramOptions')
            .appendField('Histogram options');

        // Add dynamic statement input for styling
        const stylingInput = this.appendStatementInput('styling')
            .setCheck('styling')
            .appendField('Styling');

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('Configure and render a histogram plot with specified settings.');
        this.setHelpUrl('');
        this.setColour(285);
        this.plotType = 'histogram'
        this.field = this.getFieldValue('field');
        this.fieldType = this.getFieldValue('fieldType');
        this.histType = this.getFieldValue('histType');
        this.histNumBins = 100;
        // Add default blocks for styling only if not in flyout
        if (!this.isInFlyout) {
            
            const defaultBlocks = [
                'aspect_ratio',
                'tick_direction',
                'x_axis',
                'y_axis',
                'line_properties',
                'transparency',
                'font'
            ];
            
            addDefaultStylingBlocks(this,this.workspace, defaultBlocks);

            const axis = 'x';
            updateFieldTypeDropdown(this, this.plotType, axis, 'fieldType', 'field');
            // const initialFieldType = this.getFieldValue('fieldType');
            // updateFieldDropdown(this,initialFieldType);
            // // update style dictionaries
            // updateHistogramOptions(this);
            // 3) Attach validators to fieldType and field
            const fieldTypeDropdown = this.getField('fieldType');
            fieldTypeDropdown.setValidator((newValue) => {
                this.fieldType = String(newValue);
                this.argDict = this.argDict || {};
                this.argDict['x_field_type'] = newValue;
                updateFieldDropdown(this, newValue, 'field'); // X axis
                // update style dictionaries
                updateHistogramOptions(this);
                
                return newValue;
            });

            const fieldDropdown = this.getField('field');
            fieldDropdown.setValidator((newValue) => {
                this.field = String(newValue);

                this.argDict = {
                    plot_type: this.plotType,
                    x_field: newValue,
                    x_field_type: this.field_type,     
                    hist_plot_type: this.histType,
                    hist_num_bins: this.nBins,
                }
                
                updateHistogramOptions(this);
                updateStylingChain(this, this.argDict);

            return newValue;
        });
        }
        this.setOnChange(function(event) {
            // 1) If no workspace or block is in the flyout, do nothing
            if (!this.workspace || this.isInFlyout) return;
          
            // 2) Only care about create/move/delete events
            if (
              event.type === Blockly.Events.BLOCK_CREATE ||
              event.type === Blockly.Events.BLOCK_MOVE ||
              event.type === Blockly.Events.BLOCK_DELETE
            ) {
              // 3) Check if the changed block is in the "styling" chain
              //    For instance, we can do:
              if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId)) {
                // 4) Call updateStylingChain(...)
                updateStylingChain(this);
              }
              if (isBlockInChain(this.getInputTargetBlock('histogramOptions'), event.blockId)) {
                // 4) Call updateStylingChain(...)
                updateHistogramOptions(this);
              }
            }
          });
    }
};
Blockly.common.defineBlocks({ plot_histogram: plot_histogram });

///// histogram options ////////
/**
.. block:: histogram_options
   :category: Plot
   :color: 285

Set histogram binning via width or number of bins; auto-coupled.

**Fields**
- **binWidth** (Number)
- **nBins** (Number)

**Connections**
- Previous: ``histogramOptions``
- Next: ``histogramOptions``

Notes
-----
When one field changes, the other is recomputed using the cached total
range provided by the Python side.
*/
Blockly.Blocks['histogram_options'] = {
    init: function () {
      // 1) Fields
      this.appendDummyInput()
        .appendField('Bin Width')
        .appendField(
          new Blockly.FieldNumber(1, 0, Infinity, 1),
          "binWidth"
        );
      this.appendDummyInput()
        .appendField('Num. bins')
        .appendField(
          new Blockly.FieldNumber(10, 1, 500, 1),
          "nBins"
        );
  
      // 2) Statement-chaining
      this.setPreviousStatement(true, 'histogramOptions');
      this.setNextStatement(true, 'histogramOptions');
  
      this.setTooltip('Specify bin width / num. bins for the histogram.');
      this.setHelpUrl('');
      this.setColour(285);
  
      // 3) We store a property for the histogram range
      //    If updateHistogramOptions fetches [min,max], we can store it here
      //    so that onChange can do the math.
      this.histRange = 1; // default, will be overwritten
  
      // 4) Track old values so we see which field changed
      this.oldBinWidth = this.getFieldValue('binWidth');
      this.oldNBins    = this.getFieldValue('nBins');
  
      // 5) OnChange
      this.setOnChange(function(event) {
        // If not on workspace or is in flyout, ignore
        if (!this.workspace || this.isInFlyout) return;
  
        // We only care about changes to *this* block's fields
        if (event.type === Blockly.Events.CHANGE &amp;&amp; event.blockId === this.id &amp;&amp; event.element === 'field') {
          // Which field was changed?
          const fieldName = event.name; // e.g. "binWidth" or "nBins"
          const newValue = this.getFieldValue(fieldName);
  
          const totalRange = this.histRange;
          if (totalRange &lt;= 0) {
            console.warn("Histogram range is invalid or zero in size:", this.histRange);
            return;
          }
  
          if (fieldName === 'binWidth') {
            // user typed a new binWidth => recalc nBins
            // nBins = totalRange / binWidth
            const binWidthNum = parseFloat(newValue);
            if (binWidthNum > 0) {
              const computedNBins = Math.round(totalRange / binWidthNum);
              this.setFieldValue(computedNBins, 'nBins');
            }
          } else if (fieldName === 'nBins') {
            // user typed a new nBins => recalc binWidth
            const nBinsNum = parseFloat(newValue);
            if (nBinsNum > 0) {
              const computedBinWidth = totalRange / nBinsNum;
              // optionally round to some decimal
              this.setFieldValue(String(computedBinWidth), 'binWidth');
            }
          }
  
          // Finally, update old values
          this.oldBinWidth = this.getFieldValue('binWidth');
          this.oldNBins    = this.getFieldValue('nBins');
        }
      });
    }
  };

/**
.. block:: plot_biplot
   :category: Plot
   :color: 285

Biplot (scatter or heatmap) with independent X/Y field types.

**Fields**
- **fieldTypeX**, **fieldX**, **fieldTypeY**, **fieldY** (Dropdowns, dynamic)
- **SHOW_HEATMAP** (Checkbox) toggles plot type.

**Inputs**
- **styling** (Statement: 'styling')
- **extras** (Statement: 'Regression'|'PCA')

**Connections**
- Previous: Statement
- Next: Statement
*/
const plot_biplot = {
    init: function () {
        this.appendDummyInput('header')
            .appendField('Biplot')
            .setAlign(Blockly.inputs.Align.CENTRE);

        this.appendDummyInput('XTYPE')
            .appendField('Field type X')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'fieldTypeX');
        this.appendDummyInput('XFIELD')
            .appendField('Field X')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'fieldX');
        this.appendDummyInput('YTYPE')
            .appendField('Field type Y')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'fieldTypeY');
        this.appendDummyInput('YFIELD')
            .appendField('Field Y')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'fieldY');
        this.appendDummyInput('HEATMAP')
            .appendField('Show Heatmap')
            .appendField(new Blockly.FieldCheckbox('FALSE'), 'SHOW_HEATMAP');
        // Set initial plotType
        this.plotType = 'scatter';

        const heatmapCheckbox = this.getField('SHOW_HEATMAP');
        heatmapCheckbox.setValidator((newValue) => {
            this.plotType = (newValue === 'TRUE') ? 'heatmap' : 'scatter';
            updateStylingChain(this); // If you want to update styling
            return newValue;
        });

        // Styling
        this.appendStatementInput('styling')
            .setCheck('styling')
            .appendField('Styling');
        this.appendStatementInput('extras')
            .setCheck(['Regression', 'PCA'])
            .appendField('Additional Plots');

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('Plot a biplot (scatter or heatmap) with optional regression/PCA.');
        this.setHelpUrl('');
        this.setColour(285);

        // Add default styling blocks (only if not in flyout)
        if (!this.isInFlyout) {
            const defaultBlocks = ['x_axis', 'y_axis', 'font', 'colormap'];
            addDefaultStylingBlocks(this, this.workspace, defaultBlocks);
            // update fieldType dropdowns for X and Y
            updateFieldTypeDropdown(this, this.plotType, 'x', 'fieldTypeX', 'fieldX');
            updateFieldTypeDropdown(this, this.plotType, 'y', 'fieldTypeY', 'fieldY');

            // Attach validators to fieldType and field for X and Y
            const fieldTypeXDropdown = this.getField('fieldTypeX');
            fieldTypeXDropdown.setValidator((newValue) => {
                updateFieldDropdown(this, newValue, 'fieldX'); // X axis
                return newValue;
            });
            const fieldXDropdown = this.getField('fieldX');
            fieldXDropdown.setValidator((newValue) => {
                this.argDict = {
                    plot_type: this.plotType,
                    x_field: newValue,
                    x_field_type: this.getFieldValue('fieldTypeX'),     
                }
                updateStylingChain(this);
                return newValue;
            });

            const fieldTypeYDropdown = this.getField('fieldTypeY');
            fieldTypeYDropdown.setValidator((newValue) => {
                updateFieldDropdown(this, newValue, 'fieldY'); // Y axis
                return newValue;
            });
            const fieldYDropdown = this.getField('fieldY');
            fieldYDropdown.setValidator((newValue) => {
                this.argDict = {
                    plot_type: this.plotType,
                    y_field: newValue,
                    y_field_type: this.getFieldValue('fieldTypeY'),     
                }
                updateStylingChain(this);
                return newValue;
            });
        }
        // On change, always re-sync the style chain
        this.setOnChange(function(event) {
            if (!this.workspace || this.isInFlyout) return;
            if (
              event.type === Blockly.Events.BLOCK_CREATE ||
              event.type === Blockly.Events.BLOCK_MOVE ||
              event.type === Blockly.Events.BLOCK_DELETE
            ) {
                if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId)) {
                    updateStylingChain(this);
                }
            }
        });
    }
};
Blockly.common.defineBlocks({ plot_biplot: plot_biplot });

/**
.. block:: plot_ternary
   :category: Plot
   :color: 285

Ternary scatter/heatmap with X/Y/Z field types.

**Fields**
- **fieldTypeX|Y|Z**, **fieldX|Y|Z** (Dropdowns, dynamic)
- **SHOW_HEATMAP** (Checkbox)

**Inputs**
- **styling** (Statement: 'styling')

**Connections**
- Previous: Statement
- Next: Statement
*/
const plot_ternary = {
    init: function () {
        this.appendDummyInput('header')
            .appendField('Ternary Plot')
            .setAlign(Blockly.inputs.Align.CENTRE);

        // Dynamically add axes fields and types
        ['X','Y','Z'].forEach(axis => {
            this.appendDummyInput(`${axis}TYPE`)
                .appendField(`Field type ${axis}`)
                .appendField(new Blockly.FieldDropdown([['Select...', '']]), `fieldType${axis}`);
            this.appendDummyInput(`${axis}FIELD`)
                .appendField(`Field ${axis}`)
                .appendField(new Blockly.FieldDropdown([['Select...', '']]), `field${axis}`);
        });

        // Now add the heatmap checkbox
        this.appendDummyInput('HEATMAP')
            .appendField('Show Heatmap')
            .appendField(new Blockly.FieldCheckbox('FALSE'), 'SHOW_HEATMAP');

        this.appendStatementInput('styling')
            .setCheck('styling')
            .appendField('Styling');

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('Ternary diagram (scatter or heatmap).');
        this.setHelpUrl('');
        this.setColour(285);

        // Default plot type
        this.plotType = 'scatter';
        const axisIndexMap = { X: 'x', Y: 'y', Z: 'z' };
        if (!this.isInFlyout) {
            const defaultBlocks = ['x_axis', 'y_axis', 'z_axis', 'colormap'];
            addDefaultStylingBlocks(this, this.workspace, defaultBlocks);

            // Set up validators and chain updates
            ['X','Y','Z'].forEach(axis => {
                const axisVal = axisIndexMap[axis];
                updateFieldTypeDropdown(this, this.plotType, axisVal, `fieldType${axis}`, `field${axis}`);
                    
                const fieldTypeDropdown = this.getField(`fieldType${axis}`);
                fieldTypeDropdown.setValidator((newValue) => {
                    this.argDict = this.argDict || {};
                    this.argDict[`${axis.toLowerCase()}_field_type`] = newValue;
                    updateFieldDropdown(this, newValue, `field${axis}`);
                    // After type changes, update the full chain with all info
                    return newValue;
                });

                const fieldDropdown = this.getField(`field${axis}`);
                fieldDropdown.setValidator((newValue) => {
                    this.argDict =  getTernaryArgDict(this)
                    //update new field value in dict 
                    this.argDict[`${axis.toLowerCase()}_field`]=newValue
                    updateStylingChain(this);
                    return newValue;
                });
            });

            // Heatmap checkbox validator (now field exists!)
            const heatmapCheckbox = this.getField('SHOW_HEATMAP');
            heatmapCheckbox.setValidator((newValue) => {
                this.plotType = (newValue === 'TRUE') ? 'heatmap' : 'scatter';
                updateStylingChain(this);
                return newValue;
            });
        }

        this.setOnChange(function(event) {
            if (!this.workspace || this.isInFlyout) return;
            if (
                event.type === Blockly.Events.BLOCK_CREATE ||
                event.type === Blockly.Events.BLOCK_MOVE ||
                event.type === Blockly.Events.BLOCK_DELETE
            ) {
                if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId)) {
                    updateStylingChain(this);
                }
            }
        });

        // Helper function to gather current settings into an argDict
        function getTernaryArgDict(block) {
            return {
                'plot_type': block.plotType,
                'x_field': block.getFieldValue('fieldX'),
                'x_field_type': block.getFieldValue('fieldTypeX'),
                'y_field': block.getFieldValue('fieldY'),
                'y_field_type': block.getFieldValue('fieldTypeY'),
                'z_field': block.getFieldValue('fieldZ'),
                'z_field_type': block.getFieldValue('fieldTypeZ'),
            };
        }
    }
};
Blockly.common.defineBlocks({ plot_ternary: plot_ternary });

/**
.. block:: plot_ternary_map
   :category: Plot
   :color: 285

Ternary map with X/Y/Z field types and styling.

**Fields**
- **fieldTypeX|Y|Z**, **fieldX|Y|Z**

**Inputs**
- **styling** (Statement: 'styling')

**Connections**
- Previous: Statement
- Next: Statement
*/
const plot_ternary_map = {
    init: function () {
        this.appendDummyInput('header')
            .appendField('Ternary Map')
            .setAlign(Blockly.inputs.Align.CENTRE);

        ['X','Y','Z'].forEach(axis => {
            this.appendDummyInput(`${axis}TYPE`)
                .appendField(`Field type ${axis}`)
                .appendField(new Blockly.FieldDropdown([['Select...', '']]), `fieldType${axis}`);
            this.appendDummyInput(`${axis}FIELD`)
                .appendField(`Field ${axis}`)
                .appendField(new Blockly.FieldDropdown([['Select...', '']]), `field${axis}`);
        });

        this.appendStatementInput('styling')
            .setCheck('styling')
            .appendField('Styling');

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('Ternary map.');
        this.setHelpUrl('');
        this.setColour(285);
        this.plotType = 'ternary map';
        if (!this.isInFlyout) {
            const defaultBlocks = ['x_axis', 'y_axis', 'font', 'colormap'];
            addDefaultStylingBlocks(this, this.workspace, defaultBlocks);

            ['X','Y','Z'].forEach(axis => {
                const fieldTypeDropdown = this.getField(`fieldType${axis}`);
                fieldTypeDropdown.setValidator((newValue) => {
                    this.argDict = this.argDict || {};
                    this.argDict[`${axis}_field_type`] = newValue;
                    updateFieldDropdown(this, newValue, axis);
                    updateStylingChain(this);
                    return newValue;
                });
                const fieldDropdown = this.getField(`field${axis}`);
                fieldDropdown.setValidator((newValue) => {
                    this.argDict =  getTernaryArgDict(this)
                    //update new field value in dict 
                    this.argDict[`${axis.toLowerCase()}_field`]=newValue
                    updateStylingChain(this);
                    return newValue;
                });
            });
        }
        this.setOnChange(function(event) {
            if (!this.workspace || this.isInFlyout) return;
            if (
              event.type === Blockly.Events.BLOCK_CREATE ||
              event.type === Blockly.Events.BLOCK_MOVE ||
              event.type === Blockly.Events.BLOCK_DELETE
            ) {
                if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId)) {
                    updateStylingChain(this);
                }
            }
        });
        // Helper function to gather current settings into an argDict
        function getTernaryArgDict(block) {
            return {
                'plot_type': block.plotType,
                'x_field': block.getFieldValue('fieldX'),
                'x_field_type': block.getFieldValue('fieldTypeX'),
                'y_field': block.getFieldValue('fieldY'),
                'y_field_type': block.getFieldValue('fieldTypeY'),
                'z_field': block.getFieldValue('fieldZ'),
                'z_field_type': block.getFieldValue('fieldTypeZ'),
            };
        }
    }
};
Blockly.common.defineBlocks({ plot_ternary_map: plot_ternary_map });

/* ================================
   Compatibility Diagram (TEC)
   ================================ */
   /**
.. block:: plot_ndim
   :category: Plot
   :color: 285

Compatibility (TEC/spider) diagram.

**Fields**
- **ndimAnalyteSet** (Dropdown)
- **ndimQuantiles** (Dropdown)

**Inputs**
- **styling** (Statement: 'styling')

**Connections**
- Previous: Statement
- Next: Statement

Side effects
------------
Populates options via bridge: ``getNDimAnalyteSets`` and ``getNDimQuantiles``.
*/
const plot_ndim = {
  init: function () {
    const block = this;

    block.appendDummyInput('header')
      .appendField('Compatibility diagram')
      .setAlign(Blockly.inputs.Align.CENTRE);

    block.appendDummyInput('ASET')
      .appendField('Defined set')
      .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'ndimAnalyteSet');

    block.appendDummyInput('QSEL')
      .appendField('Quantiles')
      .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'ndimQuantiles');

    // Styling chain
    block.appendStatementInput('styling')
      .setCheck('styling')
      .appendField('Styling');

    block.setPreviousStatement(true, null);
    block.setNextStatement(true, null);
    block.setTooltip('TEC (spider) diagram. Requires Reference value to be set.');
    block.setHelpUrl('');
    block.setColour(285);

    block.plotType = 'TEC';
    this.argDict = {
                    plot_type: this.plotType,
                }
    if (!block.workspace || block.workspace.isFlyout) return;

    // Defaults for TEC
    const defaultBlocks = ['font', 'line_properties', 'transparency', 'colormap'];
    addDefaultStylingBlocks(block, block.workspace, defaultBlocks);

    // Populate dropdowns
    updateNDimListDropdown(block, 'ndimList');
    updateAnalyteSetDropdown(block, 'ndimAnalyteSet');
    updateQuantilesDropdown(block, 'ndimQuantiles');

    // // Keep styling args in sync when user changes any selector
    // const refresh = () => updateStylingChain(block);

    // block.getField('ndimList')?.setValidator(() => { refresh(); return null; });
    // block.getField('ndimAnalyteSet')?.setValidator(() => { refresh(); return null; });
    // block.getField('ndimQuantiles')?.setValidator(() => { refresh(); return null; });

    // Keep styles in sync when chain mutates
    block.setOnChange(function (event) {
      if (!this.workspace || this.isInFlyout) return;
      if (event.type === Blockly.Events.BLOCK_CREATE ||
          event.type === Blockly.Events.BLOCK_MOVE ||
          event.type === Blockly.Events.BLOCK_DELETE) {
        if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId)) {
          updateStylingChain(this);
        }
      }
    });

    function updateAnalyteSetDropdown(b, fieldName) {
      window.blocklyBridge?.getNDimAnalyteSets?.()
        .then((keys) => {
          const opts = (keys || []).map(k => [k, k]);
          const dd = b.getField(fieldName);
          if (dd &amp;&amp; opts.length) {
            dd.menuGenerator_ = opts;           // simple, compatible with your codebase
            const keep = dd.getValue();
            const values = new Set(opts.map(o => o[1]));
            dd.setValue(values.has(keep) ? keep : opts[0][1]);
            dd.forceRerender?.();
          }
        })
        .catch(err => console.error('Analyte sets error:', err));
    }

    function updateQuantilesDropdown(b, fieldName) {
      window.blocklyBridge?.getNDimQuantiles?.()
        .then((items) => {
          // Accept [{label, value}, ...] or strings
          const opts = (items || []).map(it => {
            if (typeof it === 'string') return [it, it];
            const label = String(it.label ?? it.value ?? '');
            const value = String(it.value ?? label);
            return [label, value];
          });
          const dd = b.getField(fieldName);
          if (dd &amp;&amp; opts.length) {
            dd.menuGenerator_ = opts;
            const keep = dd.getValue();
            const values = new Set(opts.map(o => o[1]));
            dd.setValue(values.has(keep) ? keep : opts[0][1]);
            dd.forceRerender?.();
          }
        })
        .catch(err => console.error('Quantiles error:', err));
    }
  }
};

Blockly.common.defineBlocks({ plot_ndim });


/* ================================
   Radar Plot
   ================================ */
/**
.. block:: plot_radar
   :category: Plot
   :color: 285

Radar plot for a chosen N-dim list.

**Fields**
- **ndimList** (Dropdown)

**Inputs**
- **styling** (Statement: 'styling')

**Connections**
- Previous: Statement
- Next: Statement
*/

const plot_radar = {
    init: function () {
        this.appendDummyInput('header')
            .appendField('Radar plot')
            .setAlign(Blockly.inputs.Align.CENTRE);

        // N-dim list selector (dynamic)
        this.appendDummyInput('NDIM')
            .appendField('N-dim list')
            .appendField(new Blockly.FieldDropdown([['Select...', '']]), 'ndimList');

        // Styling chain
        this.appendStatementInput('styling')
            .setCheck('styling')
            .appendField('Styling');

        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('Radar plot. Requires Reference value to be set.');
        this.setHelpUrl('');
        this.setColour(285);

        this.plotType = 'Radar';
        this.argDict = {
                    plot_type: this.plotType,
                }
        if (!this.isInFlyout) {
            // Defaults for Radar
            const defaultBlocks = ['font', 'line_properties', 'transparency', 'colormap'];
            addDefaultStylingBlocks(this, this.workspace, defaultBlocks);

            // Populate N-dim dropdown dynamically
            updateNDimListDropdown(this, 'ndimList');

            const ndimDropdown = this.getField('ndimList');
            ndimDropdown.setValidator((newValue) => {
                updateStylingChain(this, getNDimArgDict(this));
                return newValue;
            });
        }

        this.setOnChange(function (event) {
            if (!this.workspace || this.isInFlyout) return;
            if (event.type === Blockly.Events.BLOCK_CREATE ||
                event.type === Blockly.Events.BLOCK_MOVE ||
                event.type === Blockly.Events.BLOCK_DELETE) {
                if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId)) {
                    updateStylingChain(this, getNDimArgDict(this));
                }
            }
        });

        function getNDimArgDict(block) {
            return {
                plot_type: block.plotType,          // 'Radar'
                ndim_list_key: block.getFieldValue('ndimList')
            };
        }
    }
};
Blockly.common.defineBlocks({ plot_radar: plot_radar });
/* ================================
   Clustering &amp; Dimensionality Reduction — custom_blocks.js (updated)
   ================================ */

/***** Helpers *****/
const DICE_SVG = 'data:image/svg+xml;utf8,' +
  encodeURIComponent(`&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  &lt;rect x="6" y="6" width="52" height="52" rx="10" fill="#eaeaea" stroke="#999"/>
  &lt;circle cx="20" cy="20" r="4" fill="#666"/>&lt;circle cx="44" cy="20" r="4" fill="#666"/>
  &lt;circle cx="32" cy="32" r="4" fill="#666"/>
  &lt;circle cx="20" cy="44" r="4" fill="#666"/>&lt;circle cx="44" cy="44" r="4" fill="#666"/>&lt;/svg>`);

/* Small utility to walk statement input and return first block in the chain */
function _firstInChain(block, inputName) {
  if (!block) return null;
  const head = block.getInputTargetBlock(inputName);
  return head || null;
}

/* Toggle visibility of a DummyInput by name, if it exists */
function _setInputVisible(block, inputName, visible) {
  const inp = block &amp;&amp; block.getInput(inputName);
  if (inp) {
    inp.setVisible(visible);
    block.render();
  }
}

/* ================================
   PCA — Basis variance (x: top &amp; bottom)
   ================================ */
const plot_basis_variance = {
  init: function () {
    this.appendDummyInput('HEADER')
      .appendField('Basis variance')
      .setAlign(Blockly.inputs.Align.CENTRE);

    this.appendStatementInput('styling')
      .setCheck('styling')
      .appendField('Styling');

    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(210);
    this.setTooltip('Explained and cumulative variance of PCA.');
    this.setHelpUrl('');
    this.plotType = 'variance';
    this.argDict = {
                    plot_type: this.plotType 
                }
    if (!this.isInFlyout) {
      // Default styling: marker properties, line properties, font
      const defaultBlocks = ['marker_properties', 'line_properties', 'font'];
      addDefaultStylingBlocks(this, this.workspace, defaultBlocks);
    }

    this.setOnChange(function (event) {
      if (!this.workspace || this.isInFlyout) return;
      if ([Blockly.Events.BLOCK_CREATE, Blockly.Events.BLOCK_MOVE, Blockly.Events.BLOCK_DELETE].includes(event.type)) {
        if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId)) {
          updateStylingChain(this);
        }
      }
    });
  }
};
Blockly.common.defineBlocks({ plot_basis_variance });

/* ================================
   PCA — Basis vectors plot (x: top &amp; bottom)
   ================================ */
const plot_basis_vectors_plot = {
  init: function () {
    this.appendDummyInput('HEADER')
      .appendField('Basis vectors plot')
      .setAlign(Blockly.inputs.Align.CENTRE);

    this.appendStatementInput('styling')
      .setCheck('styling')
      .appendField('Styling');

    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(210);
    this.setTooltip('Heatmap/plot of PCA basis vectors.');
    this.setHelpUrl('');
    this.plotType = 'basis vectors';
    this.argDict = {
                    plot_type: this.plotType  
                }
    if (!this.isInFlyout) {
      // Default styling: colormap, font
      const defaultBlocks = ['colormap', 'font'];
      addDefaultStylingBlocks(this, this.workspace, defaultBlocks);
    }

    this.setOnChange(function (event) {
      if (!this.workspace || this.isInFlyout) return;
      if ([Blockly.Events.BLOCK_CREATE, Blockly.Events.BLOCK_MOVE, Blockly.Events.BLOCK_DELETE].includes(event.type)) {
        if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId)) {
          updateStylingChain(this);
        }
      }
    });
  }
};
Blockly.common.defineBlocks({ plot_basis_vectors_plot });

/* ================================
   PCA — Basis vectors (styling block) (&lt;: left into styling chain)
   ================================ */
const style_basis_vectors = {
  init: function () {
    this.appendDummyInput('HEADER')
      .appendField('Basis vectors')
      .setAlign(Blockly.inputs.Align.CENTRE);

    this.appendStatementInput('styling')
      .setCheck('styling')
      .appendField('Styling');

    this.setPreviousStatement(true, 'styling');
    this.setNextStatement(true, 'styling');
    this.setColour(120);
    this.setTooltip('Styling for PCA basis vectors overlay.');
    this.setHelpUrl('');
    
    this.plotType = 'basis vectors';
    this.argDict = {
                    plot_type: this.plotType     
                }
    if (!this.isInFlyout) {
      // Default styling: line properties, transparency
      const defaultBlocks = ['line_properties', 'transparency'];
      addDefaultStylingBlocks(this, this.workspace, defaultBlocks);
    }
  }
};
Blockly.common.defineBlocks({ style_basis_vectors });





/* ================================
   Multidimensional — Clustering (x: top &amp; bottom) with dynamic defaults
   ================================ */
   /**
.. block:: plot_clustering
   :category: Multidimensional
   :color: 200

Run clustering and plot cluster map.

**Fields**
- **method** (Dropdown; populated via bridge methods list)

**Inputs**
- **seed** (Statement: ``seed``)
- **options** (Statement: ``cluster_options``)
- **styling** (Statement: 'styling')

**Connections**
- Previous: Statement
- Next: Statement

Side effects
------------
Applies defaults from bridge (seed/exponent/distance/preconditioning).
*/
const plot_clustering = {
  init: function () {
    this.appendDummyInput('HEADER')
      .appendField('Clustering')
      .setAlign(Blockly.inputs.Align.CENTRE);

    // Method dropdown is populated dynamically from AppData via bridge
    this.appendDummyInput('METHOD')
      .appendField('Method')
      .appendField(new Blockly.FieldDropdown([['Loading…', '']]), 'method');

    // Chain: Seed > Cluster options > Custom field list
    this.appendStatementInput('seed')
      .setCheck('seed')
      .appendField('Seed');

    this.appendStatementInput('options')
      .setCheck('cluster_options')
      .appendField('Cluster options');

    this.appendStatementInput('styling')
      .setCheck('styling')
      .appendField('Styling');

    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(200);
    this.setTooltip('Clustering entry point (method + seed + options + custom field list).');
    this.setHelpUrl('');
    this.plotType = 'cluster map'
    this.argDict = {
                    plot_type: this.plotType    
                }
    if (!this.isInFlyout) {
      // Default styling: marker, line width, font (use *_nc if you have “no color” variants)
      const defaultBlocks = ['marker_properties', 'line_properties', 'font'];
      addDefaultStylingBlocks(this, this.workspace, defaultBlocks);

      const methodDD = this.getField('method');

      // Load methods dynamically
      const loadMethods = () => {
        const lister = window.blocklyBridge?.getClusterMethodList;
        if (typeof lister !== 'function') return;
        lister().then((methods) => {
          const opts = (methods || []).map(m => [m, m]);
          if (!opts.length) return;
          methodDD.menuGenerator_ = opts;
          // choose previously set value or first
          const cur = methodDD.getValue();
          const vals = new Set(opts.map(o => o[1]));
          methodDD.setValue(vals.has(cur) ? cur : opts[0][1]);
          methodDD.forceRerender?.();
          applyDefaults(methodDD.getValue());
        }).catch(console.error);
      };

      // Apply defaults for selected method into child blocks
      const applyDefaults = (method) => {
        const getter = window.blocklyBridge?.getClusterDefaults;
        const specer = window.blocklyBridge?.getClusterOptionSpec;
        if (typeof getter !== 'function') return;

        getter(method).then((json) => {
          const d = typeof json === 'string' ? JSON.parse(json) : (json || {});
          // Seed
          const seedBlk = _firstInChain(this, 'seed');
          if (seedBlk &amp;&amp; seedBlk.getField('seed')) {
            seedBlk.getField('seed').setValue(d.seed != null ? String(d.seed) : '');
          }
          // Options
          const optBlk = _firstInChain(this, 'options');
          if (optBlk) {
            if (optBlk.getField('exponent') &amp;&amp; d.exponent != null) {
              optBlk.getField('exponent').setValue(Number(d.exponent));
            }
            if (optBlk.getField('distance') &amp;&amp; d.distance) {
              // ensure distance is in dropdown; if not, keep current
              const dd = optBlk.getField('distance');
              const items = (dd.menuGenerator_ || []).map(o => o[1]);
              if (items.includes(d.distance)) dd.setValue(d.distance);
            }
            if (optBlk.getField('pca')) {
              optBlk.getField('pca').setValue(d.precondition ? 'TRUE' : 'FALSE');
            }
          }
          updateStylingChain(this);
        }).catch(console.error);

        // Toggle visible/hidden fields based on option spec
        if (typeof specer === 'function') {
          specer(method).then((json) => {
            const s = typeof json === 'string' ? JSON.parse(json) : (json || {});
            const optBlk = _firstInChain(this, 'options');
            if (optBlk) {
              _setInputVisible(optBlk, 'EXP', !!s.supports_exponent);
              _setInputVisible(optBlk, 'DIST', !!s.supports_distance);
              optBlk.render();
            }
          }).catch(console.error);
        }
      };

      // Validator: when method changes, re-apply defaults
      methodDD.setValidator((nv) => {
        applyDefaults(nv);
        return nv;
      });

      // Load data now
      loadMethods();
    }

    this.setOnChange(function (event) {
      if (!this.workspace || this.isInFlyout) return;
      if ([Blockly.Events.BLOCK_CREATE, Blockly.Events.BLOCK_MOVE, Blockly.Events.BLOCK_DELETE].includes(event.type)) {
        const inStyling = isBlockInChain(this.getInputTargetBlock('styling'), event.blockId);
        const inSeed = isBlockInChain(this.getInputTargetBlock('seed'), event.blockId);
        const inOpt = isBlockInChain(this.getInputTargetBlock('options'), event.blockId);
        if (inStyling || inSeed || inOpt) updateStylingChain(this);
      }
    });
  }
};
Blockly.common.defineBlocks({ plot_clustering });

/* ================================
   Cluster performance (x: top &amp; bottom) with dynamic defaults + Max Clusters
   ================================ */
   /**
.. block:: plot_cluster_performance
   :category: Multidimensional
   :color: 200

Plot metrics for choosing optimal K (elbow, silhouette, etc.).

**Fields**
- **method** (Dropdown; dynamic)
- **maxClusters** (Number; default from bridge/app)

**Inputs**
- **seed** (Statement: ``seed``)
- **options** (Statement: ``cluster_options``)
- **styling** (Statement: 'styling')

**Connections**
- Previous: Statement
- Next: Statement
*/
const plot_cluster_performance = {
  init: function () {
    this.appendDummyInput('HEADER')
      .appendField('Cluster performance')
      .setAlign(Blockly.inputs.Align.CENTRE);

    // Method dropdown populated dynamically
    this.appendDummyInput('METHOD')
      .appendField('Method')
      .appendField(new Blockly.FieldDropdown([['Loading…', '']]), 'method');

    // Max clusters (defaults to AppData.max_clusters via bridge)
    this.appendDummyInput('MAXK')
      .appendField('Max clusters')
      .appendField(new Blockly.FieldNumber(10, 2, 1000, 1), 'maxClusters');

    this.appendStatementInput('seed')
      .setCheck('seed')
      .appendField('Seed');

    this.appendStatementInput('options')
      .setCheck('cluster_options')
      .appendField('Cluster options');

    this.appendStatementInput('styling')
      .setCheck('styling')
      .appendField('Styling');

    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(200);
    this.setTooltip('Plots for choosing optimal number of clusters (elbow, silhouette, etc.).');
    this.setHelpUrl('');
    this.plotType = 'cluster performance'
    this.argDict = {
                    plot_type: this.plotType
                }
    if (!this.isInFlyout) {
      // Default styling: marker, line width, font
      const defaultBlocks = ['marker_properties', 'line_properties', 'font'];
      addDefaultStylingBlocks(this, this.workspace, defaultBlocks);

      const methodDD = this.getField('method');
      const maxKField = this.getField('maxClusters');

      const loadMethods = () => {
        const lister = window.blocklyBridge?.getClusterMethodList;
        if (typeof lister !== 'function') return;
        lister().then((methods) => {
          const opts = (methods || []).map(m => [m, m]);
          if (!opts.length) return;
          methodDD.menuGenerator_ = opts;
          const cur = methodDD.getValue();
          const vals = new Set(opts.map(o => o[1]));
          methodDD.setValue(vals.has(cur) ? cur : opts[0][1]);
          methodDD.forceRerender?.();
          applyDefaults(methodDD.getValue());
        }).catch(console.error);
      };

      const applyDefaults = (method) => {
        const getter = window.blocklyBridge?.getClusterDefaults;
        const specer = window.blocklyBridge?.getClusterOptionSpec;
        if (typeof getter !== 'function') return;

        getter(method).then((json) => {
          const d = typeof json === 'string' ? JSON.parse(json) : (json || {});
          // Seed
          const seedBlk = _firstInChain(this, 'seed');
          if (seedBlk &amp;&amp; seedBlk.getField('seed')) {
            seedBlk.getField('seed').setValue(d.seed != null ? String(d.seed) : '');
          }
          // Options
          const optBlk = _firstInChain(this, 'options');
          if (optBlk) {
            if (optBlk.getField('exponent') &amp;&amp; d.exponent != null) {
              optBlk.getField('exponent').setValue(Number(d.exponent));
            }
            if (optBlk.getField('distance') &amp;&amp; d.distance) {
              const dd = optBlk.getField('distance');
              const items = (dd.menuGenerator_ || []).map(o => o[1]);
              if (items.includes(d.distance)) dd.setValue(d.distance);
            }
            if (optBlk.getField('pca')) {
              optBlk.getField('pca').setValue(d.precondition ? 'TRUE' : 'FALSE');
            }
          }
          // Max clusters default
          if (maxKField &amp;&amp; Number.isFinite(Number(d.max_clusters))) {
            maxKField.setValue(Number(d.max_clusters));
          }
          updateStylingChain(this);
        }).catch(console.error);

        if (typeof specer === 'function') {
          specer(method).then((json) => {
            const s = typeof json === 'string' ? JSON.parse(json) : (json || {});
            const optBlk = _firstInChain(this, 'options');
            if (optBlk) {
              _setInputVisible(optBlk, 'EXP', !!s.supports_exponent);
              _setInputVisible(optBlk, 'DIST', !!s.supports_distance);
              optBlk.render();
            }
          }).catch(console.error);
        }
      };

      methodDD.setValidator((nv) => { applyDefaults(nv); return nv; });
      if (maxKField) {
        maxKField.setValidator((nv) => { updateStylingChain(this); return nv; });
      }

      loadMethods();
    }

    this.setOnChange(function (event) {
      if (!this.workspace || this.isInFlyout) return;
      if ([Blockly.Events.BLOCK_CREATE, Blockly.Events.BLOCK_MOVE, Blockly.Events.BLOCK_DELETE].includes(event.type)) {
        const inStyling = isBlockInChain(this.getInputTargetBlock('styling'), event.blockId);
        const inSeed = isBlockInChain(this.getInputTargetBlock('seed'), event.blockId);
        const inOpt = isBlockInChain(this.getInputTargetBlock('options'), event.blockId);
        if (inStyling || inSeed || inOpt) updateStylingChain(this);
      }
    });
  }
};
Blockly.common.defineBlocks({ plot_cluster_performance });

/* ================================
   Multidimensional — Dimensional reduction (x: top &amp; bottom)
   ================================ */
   /**
.. block:: dimensional_reduction
   :category: Multidimensional
   :color: 285

Run dimensionality reduction (currently PCA).

**Fields**
- **method** (Dropdown): 'PCA: Principal component analysis'

**Inputs**
- **styling** (Statement: 'styling')

**Connections**
- Previous: Statement
- Next: Statement
*/
const dimensional_reduction = {
  init: function () {
    this.appendDummyInput('HEADER')
      .appendField('Dimensional Reduction')
      .setAlign(Blockly.inputs.Align.CENTRE);

    this.appendDummyInput('METHOD')
      .appendField('Method')
      .appendField(new Blockly.FieldDropdown([
        ['PCA: Principal component analysis', 'PCA: Principal component analysis']
      ]), 'method');

    this.appendStatementInput('styling')
      .setCheck('styling')
      .appendField('Styling');

    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(285);
    this.setTooltip('Dimensionality reduction entry point (method + custom field selection).');
    this.setHelpUrl('');
    this.plotType = 'basis vectors';
    this.argDict = {
                    plot_type: this.plotType   
                }
    if (!this.isInFlyout) {
      // Choose defaults for DR maps: colormap, font
      const defaultBlocks = ['colormap', 'font'];
      addDefaultStylingBlocks(this, this.workspace, defaultBlocks);
    }

    this.setOnChange(function (event) {
      if (!this.workspace || this.isInFlyout) return;
      if ([Blockly.Events.BLOCK_CREATE, Blockly.Events.BLOCK_MOVE, Blockly.Events.BLOCK_DELETE].includes(event.type)) {
        if (isBlockInChain(this.getInputTargetBlock('styling'), event.blockId) ) {
          updateStylingChain(this);
        }
      }
    });
  }
};
Blockly.common.defineBlocks({ dimensional_reduction });

/* ================================
   Seed block (&lt;: left) — with RNG button (uses bridge RNG if available)
   ================================ */
   /**
.. block:: cfg_seed
   :category: Multidimensional
   :color: 15

Provide a random seed for clustering (with dice button).

**Fields**
- **seed** (TextInput): Seed integer.
- **rng** (ImageButton): Generates a new seed via bridge (fallback to Math.random).

**Connections**
- Previous: ``seed``
- Next: ``seed``
*/

const cfg_seed = {
  init: function () {
    const block = this;  // capture block reference
    const seedField = new Blockly.FieldTextInput('');

    const dice = new Blockly.FieldImage(DICE_SVG, 16, 16, 'randomize', () => {
      const rng = window.blocklyBridge?.randomClusterSeed;
      const applySeed = (val) => {
        seedField.setValue(String(val));
        // force the field to visually refresh
        seedField.forceRerender?.();
      };

      if (typeof rng === 'function') {
        Promise.resolve(rng()).then(applySeed).catch(() => {
          applySeed(Math.floor(Math.random() * 1e9));
        });
      } else {
        applySeed(Math.floor(Math.random() * 1e9));
      }
    });

    block.appendDummyInput('ROW')
      .appendField('Seed')
      .appendField(dice, 'rng')
      .appendField(seedField, 'seed');

    seedField.setValidator((nv) => nv);
    block.setPreviousStatement(true, 'seed');
    block.setNextStatement(true, 'seed');
    block.setColour(15);
    block.setTooltip('Random seed for reproducibility.');
    block.setHelpUrl('');
  }
};
Blockly.common.defineBlocks({ cfg_seed });

/* ================================
   Cluster options (&lt;: left; mutator-ready stub)
   ================================ */
   /**
.. block:: cfg_cluster_options
   :category: Multidimensional
   :color: 20

Advanced clustering options and optional custom field list.

**Fields**
- **exponent** (Number)
- **distance** (Dropdown; bridge can override options)
- **pca** (Checkbox)

**Inputs**
- **customFields** (Statement: ``custom_field``)

**Connections**
- Previous: ``cluster_options``
- Next: ``cluster_options``
*/
const cfg_cluster_options = {
  init: function () {
    this.appendDummyInput('METHOD')
      .appendField('Cluster options')
      .setAlign(Blockly.inputs.Align.CENTRE);

    this.appendDummyInput('EXP')
      .appendField('Exponent')
      .appendField(new Blockly.FieldNumber(2.0, 1, 10, 0.1), 'exponent');

    this.appendDummyInput('DIST')
      .appendField('Distance')
      .appendField(new Blockly.FieldDropdown([
        ['euclidean', 'euclidean'],
        ['manhattan', 'manhattan'],
        ['cosine', 'cosine']
      ]), 'distance');

    // New: Custom field list input
    this.appendStatementInput('customFields')
      .setCheck('custom_field')
      .appendField('Custom field list');

    this.appendDummyInput('PCA')
      .appendField('PCA')
      .appendField(new Blockly.FieldCheckbox('FALSE'), 'pca');

    this.setPreviousStatement(true, 'cluster_options');
    this.setNextStatement(true, 'cluster_options');
    this.setColour(20);
    this.setTooltip('Advanced clustering options (ready for mutator extension).');
    this.setHelpUrl('');

    if (!this.isInFlyout) {
      // Optionally, populate distance list from bridge if available
      const distDD = this.getField('distance');
      const loader = window.blocklyBridge?.getClusterDistanceOptions;
      if (typeof loader === 'function') {
        loader().then((opts) => {
          const items = (opts || []).map(s => [s, s]);
          if (items.length) {
            distDD.menuGenerator_ = items;
            const cur = distDD.getValue();
            const vals = new Set(items.map(o => o[1]));
            if (!vals.has(cur)) distDD.setValue(items[0][1]);
            distDD.forceRerender?.();
          }
        }).catch(console.error);
      }
    }
  }
};
Blockly.common.defineBlocks({ cfg_cluster_options });

/* ================================
   PCA preconditioning (&lt;: left)
   ================================ */
   /**
.. block:: cfg_pca_preconditioning
   :category: Multidimensional
   :color: 20

Set number of PCA basis vectors used for preconditioning.

**Fields**
- **nBasis** (Number)

**Connections**
- Previous: ``pca_preconditioning``
- Next: ``pca_preconditioning``
*/
const cfg_pca_preconditioning = {
  init: function () {
    this.appendDummyInput('NB')
      .appendField('PCA preconditioning: No. basis')
      .appendField(new Blockly.FieldNumber(0, 0), 'nBasis');

    this.setPreviousStatement(true, 'pca_preconditioning');
    this.setNextStatement(true, 'pca_preconditioning');
    this.setColour(20);
    this.setTooltip('Number of basis vectors for PCA preconditioning.');
    this.setHelpUrl('');
  }
};
Blockly.common.defineBlocks({ cfg_pca_preconditioning });


/* ================================
    Styling Blocks
   ================================ */
   /**
.. block:: modify_styles
   :category: Style
   :color: 300

Container for style items used by plots.

**Inputs**
- **STACK** (Statement: 'styling_item')

**Connections**
- None (standalone container; used inside plot styling chains)
*/

Blockly.Blocks['modify_styles'] = {
    init: function () {
        this.appendDummyInput('axisHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Modify style');
        this.appendStatementInput('STACK')
            .setCheck('styling_item');
        this.setColour(300);
        this.setTooltip('Container for styling items.');
        this.contextMenu = false; // Hide from regular workspace context menu
    }
};

/**
.. block:: x_axis
   :category: Style
   :color: 300

Set X-axis label, limits and scale.

**Fields**
- **xLabel** (Text)
- **xLimMin**, **xLimMax** (Text)
- **xScaleDropdown** (Dropdown: linear|log|logit|symlog)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['x_axis'] = {
    init: function () {
        this.appendDummyInput('axisHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('X Axis');
        this.appendDummyInput('xLabelHeader')
        .appendField('X Label')
        .appendField(new Blockly.FieldTextInput(''), 'xLabel');
        this.appendDummyInput('xLimitsHeader')
        .appendField('X Limits')
        .appendField(new Blockly.FieldTextInput(''), 'xLimMin')
        .appendField(new Blockly.FieldTextInput(''), 'xLimMax');
        this.appendDummyInput('xScaleHeader')
        .appendField('X Scale')
        .appendField(new Blockly.FieldDropdown([
            ['Linear', 'linear'],
            ['Log', 'log'],
            ['Logit', 'logit'],
            ['Symlog', 'symlog'],
            ]), 'xScaleDropdown');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(300);
        this.setTooltip('Set X axis properties');
        this.setHelpUrl('');
    },
};

/**
.. block:: y_axis
   :category: Style
   :color: 300

Set Y-axis label, limits and scale.

**Fields**
- **yLabel**, **yLimMin**, **yLimMax**, **yScaleDropdown**

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['y_axis'] = {
    init: function () {
        this.appendDummyInput('axisHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Y Axis');
        this.appendDummyInput('yLabelHeader')
        .appendField('Y Label')
        .appendField(new Blockly.FieldTextInput(''), 'yLabel');
        this.appendDummyInput('yLimitsHeader')
        .appendField('Y Limits')
        .appendField(new Blockly.FieldTextInput(''), 'yLimMin')
        .appendField(new Blockly.FieldTextInput(''), 'yLimMax');
        this.appendDummyInput('yScaleHeader')
        .appendField('Y Scale')
        .appendField(new Blockly.FieldDropdown([
            ['Linear', 'linear'],
            ['Log', 'log'],
            ['Logit', 'logit'],
            ['Symlog', 'symlog'],
            ]), 'yScaleDropdown');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(300);
        this.setTooltip('Set Y axis properties');
        this.setHelpUrl('');
    },
};

/**
.. block:: z_axis
   :category: Style
   :color: 300

Set Z-axis label, limits and scale.

**Fields**
- **zLabel**, **zLimMin**, **zLimMax**, **zScaleDropdown**

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['z_axis'] = {
    init: function () {
        this.appendDummyInput('axisHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Z Axis');
        this.appendDummyInput('zLabelHeader')
        .appendField('Z Label')
        .appendField(new Blockly.FieldTextInput(''), 'zLabel');
        this.appendDummyInput('zLimitsHeader')
        .appendField('Z Limits')
        .appendField(new Blockly.FieldTextInput(''), 'zLimMin')
        .appendField(new Blockly.FieldTextInput(''), 'zLimMax');
        this.appendDummyInput('zScaleHeader')
        .appendField('Z Scale')
        .appendField(new Blockly.FieldDropdown([
            ['Linear', 'linear'],
            ['Log', 'log'],
            ['Logit', 'logit'],
            ['Symlog', 'symlog'],
            ]), 'zScaleDropdown');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(300);
        this.setTooltip('Set Z axis properties');
        this.setHelpUrl('');
    },
};

/**
.. block:: c_axis
   :category: Style
   :color: 300

Set colorbar label, limits and scale.

**Fields**
- **cLabel**, **cLimMin**, **cLimMax**, **cScaleDropdown**

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['c_axis'] = {
    init: function () {
        this.appendDummyInput('axisHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('C Axis');
        this.appendDummyInput('cLabelHeader')
        .appendField('C Label')
        .appendField(new Blockly.FieldTextInput(''), 'cLabel');
        this.appendDummyInput('cLimitsHeader')
        .appendField('C Limits')
        .appendField(new Blockly.FieldTextInput(''), 'cLimMin')
        .appendField(new Blockly.FieldTextInput(''), 'cLimMax');
        this.appendDummyInput('cScaleHeader')
        .appendField('c Scale')
        .appendField(new Blockly.FieldDropdown([
            ['Linear', 'linear'],
            ['Log', 'log'],
            ['Logit', 'logit'],
            ['Symlog', 'symlog'],
            ]), 'cScaleDropdown');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(300);
        this.setTooltip('Set C axis properties');
        this.setHelpUrl('');
    },
};

/**
.. block:: font
   :category: Style
   :color: 300

Set font and font size for plot text.

**Fields**
- **font** (Dropdown)
- **fontSize** (Number)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['font'] = {
    init: function () {
        this.appendDummyInput('font')
        .appendField('Font')
        .appendField(new Blockly.FieldDropdown([
            ['none', 'none'],
            ]), 'font');
        this.appendDummyInput('fontSize')
        .appendField('Font size')
        .appendField(new Blockly.FieldNumber(11, 4, 100), 'fontSize');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(300);
        this.setTooltip('Set axis label/annotation font');
        this.setHelpUrl('');
    },
};

/**
.. block:: tick_direction
   :category: Style
   :color: 300

Set tick direction.

**Fields**
- **tickDirectionDropdown** (Dropdown: out|in|inout|none)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['tick_direction'] = {
    init: function () {
        this.appendDummyInput('tickDirectionHeader')
        .appendField('Tick direction')
        .appendField(new Blockly.FieldDropdown([
            ['out', 'out'],
            ['in', 'in'],
            ['inout', 'inout'],
            ['none', 'none']
            ]), 'tickDirectionDropdown');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(300);
        this.setTooltip('Set tick direction');
        this.setHelpUrl('');
    },
};

/**
.. block:: aspect_ratio
   :category: Style
   :color: 300

Set aspect ratio string (e.g., 'equal', '1.0', '2:1').

**Fields**
- **aspectRatio** (Text)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['aspect_ratio'] = {
    init: function () {
        this.appendDummyInput('aspectRatioHeader')
        .appendField('Aspect ratio')
        .appendField(new Blockly.FieldTextInput(''), 'aspectRatio');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(300);
        this.setTooltip('Set aspect ratio');
        this.setHelpUrl('');
    },
};

/**
.. block:: add_scale
   :category: Style
   :color: 220

Add a map scale overlay.

**Fields**
- **scaleColor** (Colour)
- **scaleUnits** (Text), **scaleLength** (Text)
- **scaleDirection** (Dropdown: Horizontal|Vertical)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['add_scale'] = {
    init: function () {
        this.appendDummyInput('scaleHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Add Scale');
        this.appendDummyInput('colorSelect')
        .appendField('Color')
        .appendField(new FieldColour('#ff0000'), 'scaleColor');
        this.appendDummyInput('unitsHeader')
        .appendField('Units')
        .appendField(new Blockly.FieldTextInput(''), 'scaleUnits');
        this.appendDummyInput('lengthHeader')
        .appendField('Length')
        .appendField(new Blockly.FieldTextInput(''), 'scaleLength');
        this.appendDummyInput('directionHeader')
        .appendField('Direction')
        .appendField(new Blockly.FieldDropdown([
            ['Horizontal', 'horizontal'],
            ['Vertical', 'vertical']
            ]), 'scaleDirection');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(220);
        this.setTooltip('Add a scale to the plot.');
        this.setHelpUrl('');
    },
};

/**
.. block:: marker_properties
   :category: Style
   :color: 230

Configure marker symbol, size and color.

**Fields**
- **markerSymbol** (Dropdown)
- **markerSize** (Number)
- **markerColor** (Colour)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['marker_properties'] = {
    init: function () {
        this.appendDummyInput('markerHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Marker Properties');
        this.appendDummyInput('symbolHeader')
        .appendField('Symbol')
        .appendField(new Blockly.FieldDropdown([
            ['Circle', 'circle'],
            ['Square', 'square'],
            ['Diamond', 'diamond'],
            ['Triangle (Up)', 'triangleUp'],
            ['Triangle (Down)', 'triangleDown']
            ]), 'markerSymbol');
        this.appendDummyInput('sizeHeader')
        .appendField('Size')
        .appendField(new Blockly.FieldNumber(6, 1, 50), 'markerSize');
        this.appendDummyInput('colorSelect')
        .appendField('Color')
        .appendField(new FieldColour('#ff0000'), 'markerColor');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(230);
        this.setTooltip('Set marker properties for the plot.');
        this.setHelpUrl('');
    },
};

/**
.. block:: transparency
   :category: Style
   :color: 255

Set overall transparency (0–100).

**Fields**
- **transparency** (Number)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['transparency'] = {
    init: function () {
        this.appendDummyInput('transparency')
        .appendField('Transparency')
        .appendField(new Blockly.FieldNumber(100, 0, 100), 'transparency');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(255);
        this.setTooltip('Adjust transparency of plot');
        this.setHelpUrl('');
    },
};

/**
.. block:: line_properties
   :category: Style
   :color: 230

Configure line width and color.

**Fields**
- **lineWidth** (Number)
- **lineColor** (Colour)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['line_properties'] = {
    init: function () {
        this.appendDummyInput('lineHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Line Properties');
        this.appendDummyInput('lineWidthHeader')
        .appendField('Width')
        .appendField(new Blockly.FieldNumber(1, 0.1, 10, 0.1), 'lineWidth');
        this.appendDummyInput('lineColorHeader')
        .appendField('Color')
        .appendField(new FieldColour('#000000'), 'lineColor');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(230);
        this.setTooltip('Set line properties for the plot.');
        this.setHelpUrl('');
    },
};

/**
.. block:: color_select
   :category: Style
   :color: 240

Small value block that outputs a color.

**Fields**
- **colorPicker** (Colour)

**Connections**
- Output: any
*/
Blockly.Blocks['color_select'] = {
    init: function () {
        this.appendDummyInput('colorHeader')
        .appendField('Color Select')
        .appendField(new FieldColour('#ff0000'), 'colorPicker');
        this.setOutput(true, null);
        this.setColour(240);
        this.setTooltip('Select a color.');
        this.setHelpUrl('');
    },
};

/**
.. block:: color_field
   :category: Style
   :color: 245

Select a field used for coloring.

**Fields**
- **fieldType**, **field** (Dropdowns)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['color_field'] = {
    init: function () {
        this.appendDummyInput('colorFieldHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Color Field');
        this.appendDummyInput('fieldTypeHeader')
        .appendField('Field Type')
        .appendField(new Blockly.FieldDropdown([
            ['Type A', 'typeA'],
            ['Type B', 'typeB']
            ]), 'fieldType');
        this.appendDummyInput('fieldHeader')
        .appendField('Field')
        .appendField(new Blockly.FieldDropdown([
            ['Option 1', 'option1'],
            ['Option 2', 'option2']
            ]), 'field');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(245);
        this.setTooltip('Select a field for coloring.');
        this.setHelpUrl('');
    },
};

/**
.. block:: colormap
   :category: Style
   :color: 250

Colormap selection, reverse and orientation.

**Fields**
- **colormap** (Dropdown)
- **reverse** (Checkbox)
- **direction** (Dropdown: Horizontal|Vertical)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['colormap'] = {
    init: function () {
        this.appendDummyInput('colormapHeader')
        .setAlign(Blockly.inputs.Align.CENTRE)
        .appendField('Colormap');
        this.appendDummyInput('mapHeader')
        .appendField('Colormap')
        .appendField(new Blockly.FieldDropdown([
            ['Jet', 'jet'],
            ['Viridis', 'viridis'],
            ['Plasma', 'plasma']
            ]), 'colormap');
        this.appendDummyInput('reverseHeader')
        .appendField('Reverse')
        .appendField(new Blockly.FieldCheckbox('FALSE'), 'reverse');
        this.appendDummyInput('directionHeader')
        .appendField('Direction')
        .appendField(new Blockly.FieldDropdown([
            ['Horizontal', 'horizontal'],
            ['Vertical', 'vertical']
            ]), 'direction');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(250);
        this.setTooltip('Set colormap properties.');
        this.setHelpUrl('');
    },
};

/**
.. block:: show_mass
   :category: Style
   :color: 255

Toggle display of mass curves/overlays (if supported by plot).

**Fields**
- **showMass** (Checkbox)

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['show_mass'] = {
    init: function () {
        this.appendDummyInput('massHeader')
        .appendField('Show Mass')
        .appendField(new Blockly.FieldCheckbox('FALSE'), 'showMass');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(255);
        this.setTooltip('Toggle visibility of mass in the plot.');
        this.setHelpUrl('');
    },
};

/**
.. block:: color_by_cluster
   :category: Style
   :color: 255

Color plots by cluster assignment.

**Fields**
- **clusterType** (Dropdown): Selector for cluster field.

**Connections**
- Previous: 'styling'
- Next: 'styling'
*/
Blockly.Blocks['color_by_cluster'] = {
    init: function () {
        this.appendDummyInput('clusterHeader')
        .appendField('Color by Cluster');
        this.appendDummyInput('clusterOptions')
        .appendField(new Blockly.FieldDropdown([
            ['Cluster 1', 'cluster1'],
            ['Cluster 2', 'cluster2']
            ]), 'clusterType');
        this.setPreviousStatement(true, 'styling');
        this.setNextStatement(true, 'styling');
        this.setColour(255);
        this.setTooltip('Color plot based on cluster classification.');
        this.setHelpUrl('');
    },
};



/**
.. block:: profiling
   :category: Analysis
   :color: 160

Extract and visualize profiles across the map.

**Fields**
- **PROFILE_NAME** (Text)
- **SORT_AXIS** (Dropdown: X|Y)
- **RADIUS**, **THRESHOLD**, **INT_DISTANCE** (Numbers)
- **POINT_ERROR** (Dropdown: median|mean)
- **INTERPOLATE** (Checkbox)
- **NUM_SUBPLOTS** (Number)

**Inputs**
- **FIELDS** (Value: Array)

**Connections**
- Previous: Statement
- Next: Statement
*/
const profiling = {
    init: function() {
        this.appendDummyInput()
            .appendField('Profiling');
        this.appendDummyInput()
            .appendField('Profile Name')
            .appendField(new Blockly.FieldTextInput('Profile1'), 'PROFILE_NAME');
        this.appendDummyInput()
            .appendField('Sort Axis')
            .appendField(new Blockly.FieldDropdown([
                ['X', 'x'],
                ['Y', 'y']
            ]), 'SORT_AXIS');
        this.appendDummyInput()
            .appendField('Radius')
            .appendField(new Blockly.FieldNumber(10, 0), 'RADIUS');
        this.appendDummyInput()
            .appendField('Threshold')
            .appendField(new Blockly.FieldNumber(0), 'THRESHOLD');
        this.appendDummyInput()
            .appendField('Interpolation Distance')
            .appendField(new Blockly.FieldNumber(1, 0), 'INT_DISTANCE');
        this.appendDummyInput()
            .appendField('Point Error')
            .appendField(new Blockly.FieldDropdown([
                ['Median + IQR', 'median'],
                ['Mean + Standard Error', 'mean']
            ]), 'POINT_ERROR');
        this.appendValueInput('FIELDS')
            .setCheck('Array')
            .appendField('Fields');
        this.appendDummyInput()
            .appendField('Number of Subplots')
            .appendField(new Blockly.FieldNumber(1, 1), 'NUM_SUBPLOTS');
        this.appendDummyInput()
            .appendField('Interpolate Points')
            .appendField(new Blockly.FieldCheckbox('FALSE'), 'INTERPOLATE');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip('Performs profiling with specified settings.');
        this.setHelpUrl('');
    }
};
Blockly.Blocks['profiling'] = profiling;


/* ---------- Category/role registration ---------- */
[
  // Global Settings
  ['display_figure',              { category:'GLOBAL', role:'ENTRY',  tooltip:'Toggle modal canvas vs embedded plotting.' }],

  // File I/O
  ['load_directory',              { category:'FILE_IO', role:'DATA',   tooltip:'Load all files from a directory.' }],
  ['load_sample',                 { category:'FILE_IO', role:'DATA',   tooltip:'Load a single sample from a path.' }],
  ['loop_over_samples',           { category:'FILE_IO', role:'AUX',    tooltip:'Iterate over all sample IDs.' }],
  ['loop_over_fields',            { category:'FILE_IO', role:'AUX',    tooltip:'Iterate over fields of a selected type.' }],
  ['export_table',                { category:'FILE_IO', role:'DATA',   tooltip:'Select fields to export as a table.' }],
  ['save_plot',                   { category:'FILE_IO', role:'DATA',   tooltip:'Save current figure/data to disk.' }],

  // Samples &amp; fields
  ['select_samples',              { category:'SAMPLES', role:'ENTRY',  tooltip:'Select a sample ID.' }],
  ['select_analytes',             { category:'SAMPLES', role:'ENTRY',  tooltip:'Choose analytes/ratios via dialog or list.' }],
  ['select_field_from_type',      { category:'SAMPLES', role:'ENTRY',  tooltip:'Pick one/all/none from a field type.' }],
  ['select_fields_list',          { category:'SAMPLES', role:'ENTRY',  tooltip:'Use field selector/current selection/saved list.' }],
  ['select_ref_val',              { category:'SAMPLES', role:'AUX',    tooltip:'Choose a reference value set.' }],
  ['change_pixel_dimensions',     { category:'SAMPLES', role:'AUX',    tooltip:'Set dx/dy from dataset defaults.' }],
  ['swap_pixel_dimensions',       { category:'SAMPLES', role:'AUX',    tooltip:'Swap dx and dy.' }],
  ['swap_x_y',                    { category:'SAMPLES', role:'AUX',    tooltip:'Swap x and y axes.' }],
  ['select_outlier_method',       { category:'SAMPLES', role:'OPTIONS',tooltip:'Outlier handling method and bounds.' }],
  ['neg_handling_method',         { category:'SAMPLES', role:'OPTIONS',tooltip:'Negative value handling strategy.' }],

  // Analysis
  {},

  // Plot
  ['plot_map',                    { category:'PLOT', role:'ENTRY',     tooltip:'Render a 2D field map.' }],
  ['plot_correlation',            { category:'PLOT', role:'ENTRY',     tooltip:'Correlation analysis and plot.' }],
  ['plot_histogram',              { category:'PLOT', role:'ENTRY',     tooltip:'Histogram of a field (PDF/CDF/log).' }],
  ['histogram_options',           { category:'PLOT', role:'OPTIONS',   tooltip:'Bin width / number of bins.' }],
  ['plot_biplot',                 { category:'PLOT', role:'ENTRY',     tooltip:'Biplot (scatter/heatmap) with X/Y fields.' }],
  ['plot_ternary',                { category:'PLOT', role:'ENTRY',     tooltip:'Ternary scatter/heatmap.' }],
  ['plot_ternary_map',            { category:'PLOT', role:'ENTRY',     tooltip:'Ternary map (X/Y/Z fields).' }],
  ['plot_ndim',                   { category:'PLOT', role:'ENTRY',     tooltip:'Compatibility (TEC) diagram.' }],
  ['plot_radar',                  { category:'PLOT', role:'ENTRY',     tooltip:'Radar plot for an N-dim list.' }],
  ['profiling',                   { category:'PLOT', role:'ENTRY',     tooltip:'Extract and plot profiles across the map.' }],
  // Multidimensional
  ['cfg_seed',                    { category:'MULTI', role:'OPTIONS',  tooltip:'Random seed for clustering.' }],
  ['cfg_cluster_options',         { category:'MULTI', role:'OPTIONS',  tooltip:'Exponent, distance, PCA, and custom fields.' }],
  ['cfg_pca_preconditioning',     { category:'MULTI', role:'OPTIONS',  tooltip:'Number of PCA basis for preconditioning.' }],
  ['plot_clustering',             { category:'MULTI', role:'ENTRY',    tooltip:'Cluster and render cluster map.' }],
  ['plot_cluster_performance',    { category:'MULTI', role:'ENTRY',    tooltip:'Elbow/silhouette etc. vs. K.' }],
  ['dimensional_reduction',       { category:'MULTI', role:'ENTRY',    tooltip:'Run dimensional reduction (PCA).' }],

  // Style
  ['modify_styles',               { category:'STYLE', role:'STYLING',  tooltip:'Container for styling items.' }],
  ['x_axis',                      { category:'STYLE', role:'STYLING',  tooltip:'X axis label/limits/scale.' }],
  ['y_axis',                      { category:'STYLE', role:'STYLING',  tooltip:'Y axis label/limits/scale.' }],
  ['z_axis',                      { category:'STYLE', role:'STYLING',  tooltip:'Z axis label/limits/scale.' }],
  ['c_axis',                      { category:'STYLE', role:'STYLING',  tooltip:'Colorbar label/limits/scale.' }],
  ['font',                        { category:'STYLE', role:'STYLING',  tooltip:'Font family/size.' }],
  ['tick_direction',              { category:'STYLE', role:'STYLING',  tooltip:'Tick direction.' }],
  ['aspect_ratio',                { category:'STYLE', role:'STYLING',  tooltip:'Aspect ratio.' }],
  ['add_scale',                   { category:'STYLE', role:'STYLING',  tooltip:'Add a map scale overlay.' }],
  ['marker_properties',           { category:'STYLE', role:'STYLING',  tooltip:'Marker symbol/size/color.' }],
  ['transparency',                { category:'STYLE', role:'STYLING',  tooltip:'Overall transparency.' }],
  ['line_properties',             { category:'STYLE', role:'STYLING',  tooltip:'Line width/color.' }],
  ['color_select',                { category:'STYLE', role:'STYLING',  tooltip:'Outputs a color value.' }],
  ['color_field',                 { category:'STYLE', role:'STYLING',  tooltip:'Select a field for coloring.' }],
  ['colormap',                    { category:'STYLE', role:'STYLING',  tooltip:'Colormap + reverse + orientation.' }],
  ['show_mass',                   { category:'STYLE', role:'STYLING',  tooltip:'Toggle mass overlays.' }],
  ['color_by_cluster',            { category:'STYLE', role:'STYLING',  tooltip:'Color by cluster assignment.' }],
].forEach(([type, opts]) => decorateBlock(type, opts));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addDefaultStylingBlocks">addDefaultStylingBlocks</a></li><li><a href="global.html#cfg_cluster_options">cfg_cluster_options</a></li><li><a href="global.html#cfg_pca_preconditioning">cfg_pca_preconditioning</a></li><li><a href="global.html#cfg_seed">cfg_seed</a></li><li><a href="global.html#change_pixel_dimensions">change_pixel_dimensions</a></li><li><a href="global.html#dimensional_reduction">dimensional_reduction</a></li><li><a href="global.html#display_figure">display_figure</a></li><li><a href="global.html#getConnectedBlocks">getConnectedBlocks</a></li><li><a href="global.html#isBlockInChain">isBlockInChain</a></li><li><a href="global.html#listSelectorChanged">listSelectorChanged</a></li><li><a href="global.html#load_directory">load_directory</a></li><li><a href="global.html#load_sample">load_sample</a></li><li><a href="global.html#loop_over_fields">loop_over_fields</a></li><li><a href="global.html#loop_over_samples">loop_over_samples</a></li><li><a href="global.html#neg_handling_method">neg_handling_method</a></li><li><a href="global.html#plot_biplot">plot_biplot</a></li><li><a href="global.html#plot_cluster_performance">plot_cluster_performance</a></li><li><a href="global.html#plot_clustering">plot_clustering</a></li><li><a href="global.html#plot_correlation">plot_correlation</a></li><li><a href="global.html#plot_histogram">plot_histogram</a></li><li><a href="global.html#plot_map">plot_map</a></li><li><a href="global.html#plot_ndim">plot_ndim</a></li><li><a href="global.html#plot_radar">plot_radar</a></li><li><a href="global.html#plot_ternary">plot_ternary</a></li><li><a href="global.html#plot_ternary_map">plot_ternary_map</a></li><li><a href="global.html#profiling">profiling</a></li><li><a href="global.html#refreshAllFieldTypeDropdowns">refreshAllFieldTypeDropdowns</a></li><li><a href="global.html#refreshCustomFieldListsDropdown">refreshCustomFieldListsDropdown</a></li><li><a href="global.html#resizeBlocklyWorkspace">resizeBlocklyWorkspace</a></li><li><a href="global.html#select_outlier_method">select_outlier_method</a></li><li><a href="global.html#select_ref_val">select_ref_val</a></li><li><a href="global.html#select_samples">select_samples</a></li><li><a href="global.html#setDefaultSaveDir">setDefaultSaveDir</a></li><li><a href="global.html#swap_pixel_dimensions">swap_pixel_dimensions</a></li><li><a href="global.html#swap_x_y">swap_x_y</a></li><li><a href="global.html#updateBinWidthAndNBins">updateBinWidthAndNBins</a></li><li><a href="global.html#updateCAxisBlock">updateCAxisBlock</a></li><li><a href="global.html#updateFieldDropdown">updateFieldDropdown</a></li><li><a href="global.html#updateFieldTypeDropdown">updateFieldTypeDropdown</a></li><li><a href="global.html#updateFieldTypeList">updateFieldTypeList</a></li><li><a href="global.html#updateHistogramOptions">updateHistogramOptions</a></li><li><a href="global.html#updateNDimListDropdown">updateNDimListDropdown</a></li><li><a href="global.html#updateSavePlotPreview">updateSavePlotPreview</a></li><li><a href="global.html#updateSavedListsDropdown">updateSavedListsDropdown</a></li><li><a href="global.html#updateStylingChain">updateStylingChain</a></li><li><a href="global.html#updateXAxisBlock">updateXAxisBlock</a></li><li><a href="global.html#updateYAxisBlock">updateYAxisBlock</a></li><li><a href="global.html#updateZAxisBlock">updateZAxisBlock</a></li><li><a href="global.html#workspace">workspace</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Sep 16 2025 07:19:31 GMT+0930 (Australian Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
